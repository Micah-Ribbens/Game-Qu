<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>game_qu.platformer.player API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>game_qu.platformer.player</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from math import sqrt
from game_qu.base.lines import LineSegment
from game_qu.base.events import TimedEvent
from game_qu.base.game_movement import GameMovement

from game_qu.base.quadratic_equations import PhysicsPath
from game_qu.base.history_keeper import HistoryKeeper
from game_qu.base.velocity_calculator import VelocityCalculator
from game_qu.math.bounded_function import BoundedFunction
from game_qu.math.function import Function
from game_qu.math.linear_interpolation import LinearInterpolation
from game_qu.math.physics_function import PhysicsFunction
from game_qu.math.piecewise_function import PiecewiseFunction
from game_qu.math.point import Point
from game_qu.math.polynomial import Polynomial
from game_qu.paths.piecewise_followable_path import PiecewiseFollowablePath
from game_qu.platformer.weapon_user import WeaponUser
from game_qu.base.utility_functions import *
from game_qu.platformer.constants import *


class Player(WeaponUser):
    &#34;&#34;&#34;The way that people can play the game (accepts user input to move)&#34;&#34;&#34;

    all_paths_and_events = []

    # Modifiable Variables
    length = VelocityCalculator.get_dimension(SCREEN_LENGTH, 5)
    height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 15)

    total_hit_points = 50
    object_type = &#34;Player&#34;

    # So you can control all the jump movements (it feels better if there is different jump arcs for up and down)
    apex_jump_time = 0.1
    apex_horizontal_velocity_multiplier = 1.25
    coyote_time = 0.2
    terminal_velocity = VelocityCalculator.get_velocity(SCREEN_LENGTH, 1500)
    jump_buffer_time = 0.5

    # Variable Jump Heights
    time_to_high_jump_vertex = 0.55
    time_from_high_jump_vertex_to_ground = 0.35
    high_jump_height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 30)
    high_jump_time_held_in = 0.35

    time_to_medium_jump_vertex = 0.4
    time_from_medium_jump_vertex_to_ground = 0.2
    medium_jump_height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 20)
    medium_jump_time_held_in = 0.2

    time_to_small_jump_vertex = 0.3
    time_from_small_jump_vertex_to_ground = 0.2
    small_jump_height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 10)
    small_jump_time_held_in = 0.1

    running_deceleration_time = 0.3
    invincibility_total_time = 1
    max_horizontal_velocity = VelocityCalculator.get_velocity(SCREEN_LENGTH, 500)
    running_acceleration_time = 0.2

    minimum_jump_deceleration_time = 0.1

    # Miscellaneous
    hit_points_left = total_hit_points
    jumping_path = None
    deceleration_path = None
    acceleration_path = None
    current_velocity = 0
    initial_upwards_velocity = 0
    invincibility_event = None
    platform_is_on = None
    last_platform_was_on = None
    # So the player can be run and side scrolling can be done before the rendering (otherwise it doesn&#39;t look smooth)
    is_runnable = False
    has_jumped = False
    jumping_piecewise_function = None
    falling_piecewise_function = None
    time_to_jump_type = None
    coyote_timed_event = None
    jump_buffer_timed_event = None
    base_left_edge = -1
    base_top_edge = -1
    jump_key_held_in_time = -1

    # Booleans
    can_move_down = False
    can_move_left = False
    can_move_right = False
    is_on_platform = True
    is_facing_right = True

    # Keys
    left_key = None
    right_key = None
    jump_key = None
    down_key = None
    attack_key = None

    def __init__(self, left_key, right_key, jump_key, down_key, attack_key):
        &#34;&#34;&#34;Initializes the object&#34;&#34;&#34;

        super().__init__(&#34;&#34;)

        self.left_key, self.right_key, self.jump_key = left_key, right_key, jump_key
        self.down_key, self.attack_key = down_key, attack_key
        self.invincibility_event = TimedEvent(self.invincibility_total_time, False)
        self.coyote_timed_event = TimedEvent(self.coyote_time, False)
        self.jump_buffer_timed_event = TimedEvent(self.jump_buffer_time, False)

        self.create_paths()
        self.all_paths_and_events = [self.jumping_path, self.deceleration_path, self.acceleration_path]
        self.jumping_functions = [self._set_jumping_path_to_small_jump, self._set_jumping_path_to_medium_jump,
                                  self._set_jumping_path_to_high_jump]

    def create_paths(self):
        &#34;&#34;&#34;Creates all the paths for the player: jumping_path, decelerating_path, etc.&#34;&#34;&#34;

        self.jumping_piecewise_function = PiecewiseFunction([])
        self.falling_piecewise_function = PiecewiseFunction([])

        self.jumping_path = PiecewiseFollowablePath(self.jumping_piecewise_function, game_object=self, attribute_modifying=&#34;top_edge&#34;)

        self.set_running_acceleration_time(self.running_acceleration_time)
        self.set_running_deceleration_time(self.running_deceleration_time)

    def run(self):
        &#34;&#34;&#34;Runs all the code that is necessary for the player to work properly&#34;&#34;&#34;

        self.invincibility_event.run(self.invincibility_event.current_time &gt; self.invincibility_event.time_needed, False)
        self.run_horizontal_movement()
        self.run_vertical_movement()

    def run_vertical_movement(self):
        &#34;&#34;&#34;Runs all the vertical movement (mostly jumping)&#34;&#34;&#34;

        if game_button_is_clicked(self.jump_key):
            if self.is_on_platform:
                self.jump()

            if self.coyote_timed_event.is_running():
                self.jump()
                self.coyote_timed_event.reset()

        if game_button_has_been_released(self.jump_key):
            self.jump_key_held_in_time = get_time_of_game_button_being_held_in(self.jump_key)

            if self.has_jumped:
                self.run_jump_type(self.jump_key_held_in_time)

        if self.top_edge &lt;= 0:
            self.run_bottom_edge_collision(0)

        self.jumping_path.run(is_changing_attribute=True)

    def run_horizontal_movement(self):
        &#34;&#34;&#34;Runs all the code for horizontal movement: acceleration, deceleration, etc.&#34;&#34;&#34;

        self.is_facing_right = True if game_button_is_pressed(self.right_key) else self.is_facing_right
        self.is_facing_right = False if game_button_is_pressed(self.left_key) else self.is_facing_right

        self.run_deceleration()
        self.run_acceleration()

        GameMovement.player_horizontal_movement(self, self.current_velocity, self.left_key, self.right_key)

    def run_acceleration(self):
        &#34;&#34;&#34;Runs all the code for acceleration (so the player comes to the max velocity)&#34;&#34;&#34;

        if self.player_movement_direction_is_same_as_deceleration():
            self.continue_acceleration_after_partial_deceleration()

        if self.deceleration_path.has_finished():
            GameMovement.run_acceleration(self, game_button_is_pressed(self.left_key) or game_button_is_pressed(self.right_key), self.acceleration_path, self.max_horizontal_velocity)

        if not self.acceleration_direction_is_possible(self.acceleration_path.acceleration &gt; 0):
            self.acceleration_path.reset()

    def run_deceleration(self):
        &#34;&#34;&#34;Runs all the code for decelerating (so the player comes to a stop slowly)&#34;&#34;&#34;

        deceleration_direction_is_possible = self.acceleration_direction_is_possible(self.get_deceleration_is_rightwards())

        # Meaning no outside force has stopped the deceleration like platforms or screen limits
        deceleration_has_manually_stopped = self.deceleration_path.has_finished() or self.player_movement_direction_is_same_as_deceleration()
        can_decelerate = deceleration_direction_is_possible and not deceleration_has_manually_stopped

        if can_decelerate:
            self.deceleration_path.run(False, False, is_changing_coordinates=False)
            self.left_edge += self.deceleration_path.get_total_displacement()

        else:
            self.deceleration_path.reset()

        if self.horizontal_movement_has_stopped():
            self.decelerate_player(game_button_has_been_released(self.right_key))

    def horizontal_movement_has_stopped(self):
        &#34;&#34;&#34;
            Returns:
                boolean: if horizontal movement has stopped (player has released a movement key)&#34;&#34;&#34;

        return game_button_has_been_released(self.right_key) or game_button_has_been_released(self.left_key)

    def acceleration_direction_is_possible(self, movement_is_rightwards):
        &#34;&#34;&#34;
            Returns:
                boolean: whether the path acceleration&#39;s movement is not possible because of either the screen or a platform
                | This is used for both the acceleration_path and deceleration_path. Figures out if the direction of acceleration
                is possible (if it can&#39;t move right it can&#39;t accelerate right&#34;&#34;&#34;

        return self.can_move_right if movement_is_rightwards else self.can_move_left

    def set_is_on_platform(self, is_on_platform, platform_is_on):
        &#34;&#34;&#34;Sets the player&#39;s &#39;is_on_platform&#39; attribute&#34;&#34;&#34;

        if not self.is_on_platform and is_on_platform:
            self.jumping_path.reset()

        if self.is_on_platform and not is_on_platform and not self.has_jumped:
            self.set_jumping_path_to_falling_path()

        if self.jump_buffer_timed_event.is_running():
            self.jump()
            self.jump_buffer_timed_event.reset()

        self.last_platform_was_on = platform_is_on if is_on_platform else self.last_platform_was_on
        self.platform_is_on = platform_is_on if is_on_platform else None
        self.is_on_platform = is_on_platform

    def reset(self):
        &#34;&#34;&#34;Resets the player back to the start of the game&#34;&#34;&#34;

        self.left_edge = self.base_left_edge
        self.top_edge = self.base_top_edge

        self.weapon.reset()
        self.run_respawning()  # Resetting from the game ending and respawning has a lot in similarity

    def run_respawning(self):
        &#34;&#34;&#34;Makes the player respawn (resets most things)&#34;&#34;&#34;

        self.is_on_platform = True
        self.hit_points_left = self.total_hit_points
        self.invincibility_event.reset()

        # Resetting the direction the player can move
        self.can_move_left, self.can_move_right, self.can_move_down = False, False, False

        for path_or_event in self.all_paths_and_events:
            path_or_event.reset()

    def jump(self):
        &#34;&#34;&#34;Makes the player jump&#34;&#34;&#34;

        self.jumping_path.start()
        self.set_jumping_path_to_default_jump()
        self.has_jumped = True

        if self.jump_key_held_in_time != -1:
            self.run_jump_type()

    def decelerate_player(self, is_moving_right):
        &#34;&#34;&#34;Makes the player decelerate by calling deceleration_path.start()&#34;&#34;&#34;

        self.deceleration_path.initial_distance = self.left_edge
        self.deceleration_path.initial_velocity = self.current_velocity if is_moving_right else -self.current_velocity

        # If the player is not at maximum velocity it shouldn&#39;t take as long to decelerate
        fraction_of_max_velocity = self.current_velocity / self.max_horizontal_velocity
        time_needed = self.running_deceleration_time * fraction_of_max_velocity

        # Gotten using math; Makes the player stop in the amount of time &#39;self.running_deceleration_time&#39;
        self.deceleration_path.acceleration = -self.deceleration_path.initial_velocity / time_needed

        self.deceleration_path.start()
        self.deceleration_path.max_time = time_needed

    def player_movement_direction_is_same_as_deceleration(self):
        &#34;&#34;&#34;
            Returns:
                boolean: if the direction the player is moving is equal to the deceleration&#34;&#34;&#34;

        deceleration_direction_is_rightwards = self.deceleration_path.acceleration &lt; 0

        # Looking at both the leftwards and rightwards movement: movement and deceleration have both to be leftwards or rightwards
        rightwards_movement_is_same_as_deceleration = deceleration_direction_is_rightwards and game_button_is_pressed(self.right_key)
        leftwards_movement_is_same_as_deceleration = not deceleration_direction_is_rightwards and game_button_is_pressed(self.left_key)

        return leftwards_movement_is_same_as_deceleration or rightwards_movement_is_same_as_deceleration

    def continue_acceleration_after_partial_deceleration(self):
        &#34;&#34;&#34;Updates the time of the acceleration_path, so that it will pick up at the velocity where the deceleration ended at&#34;&#34;&#34;

        current_velocity = self.deceleration_path.get_velocity_using_time(self.deceleration_path.current_time)
        self.acceleration_path.start()

        # Figuring out the time to get to that velocity, so the player can continue to accelerate to the max velocity
        self.acceleration_path.current_time = sqrt(abs(current_velocity) / self.acceleration_path.acceleration)

    def run_bottom_edge_collision(self, top_edge):
        &#34;&#34;&#34;Runs what should happen after a bottom collision (the player should rebound off of it)&#34;&#34;&#34;

        velocity = self.get_vertical_velocity()
        falling_function = PhysicsFunction(self.high_jump_height, self.time_to_high_jump_vertex, self.top_edge)
        falling_function.set_initial_velocity(velocity)
        functions = self.get_jumping_path_bounded_functions([falling_function],
                                                            [self.time_from_high_jump_vertex_to_ground])

        self.falling_piecewise_function.set_functions(functions)
        self.set_jumping_path_to_falling_path()

        self.jumping_path.reset()
        self.top_edge = top_edge

    def get_horizontal_velocity(self):
        &#34;&#34;&#34;
            Returns:
                double: the current velocity of the player&#34;&#34;&#34;

        # The velocity of the player is two-fold: either it has its usual velocity when it is not decelerating, or it has
        # The velocity from the deceleration. The deceleration_path does not affect the current_velocity because it was
        # Easier not to do that, so it does not do it that way
        deceleration_velocity = self.deceleration_path.get_velocity_using_time(self.deceleration_path.current_time)
        normal_velocity = self.current_velocity

        return normal_velocity if self.deceleration_path.has_finished() else deceleration_velocity

    # Collision Stuff
    def run_inanimate_object_collision(self, inanimate_object, index_of_sub_component):
        &#34;&#34;&#34;Runs what should happen when the player collides with an inanimate object&#34;&#34;&#34;

        if index_of_sub_component == self.index_of_user:
            self.update_platform_collision_data(inanimate_object)

        if index_of_sub_component != self.index_of_user:
            self.weapon.run_inanimate_object_collision(inanimate_object, index_of_sub_component - self.weapon_index_offset)

    def run_collisions(self):
        &#34;&#34;&#34;Runs what should happen based on what got stored in the collision data&#34;&#34;&#34;

        # The player should only act upon the collision data if there was stuff in the History Keeper because if there wasn&#39;t
        # Then the game is automatically going to say it was not a collision (top, left, right, bottom)
        if HistoryKeeper.get_last(self.name) is not None:
            self.alter_player_horizontal_movement()
            self.alter_player_vertical_movement()

    def alter_player_horizontal_movement(self):
        &#34;&#34;&#34;Alters the player&#39;s horizontal movement so it stays within the screen and is not touching the platforms&#34;&#34;&#34;

        player_is_beyond_screen_left = is_beyond_screen_left(self.left_edge)
        player_is_beyond_screen_right = is_beyond_screen_right(self.right_edge)

        self.alter_player_horizontal_movement_booleans(player_is_beyond_screen_left, player_is_beyond_screen_right)
        self.alter_player_left_edge_if_necessary(player_is_beyond_screen_left, player_is_beyond_screen_right)

    def alter_player_horizontal_movement_booleans(self, player_is_beyond_screen_left, player_is_beyond_screen_right):
        &#34;&#34;&#34;Alters the player&#39;s horizontal movement direction boolean attributes: &#39;can_move_left&#39; and &#39;can_move_right&#39;&#34;&#34;&#34;

        is_decelerating_rightwards = not self.deceleration_path.has_finished() and self.get_deceleration_is_rightwards()
        is_decelerating_leftwards = not self.deceleration_path.has_finished() and not self.get_deceleration_is_rightwards()

        # Possible relating to everything but the deceleration
        leftwards_movement_is_possible = not self.right_collision_data[0] and not player_is_beyond_screen_left
        rightwards_movement_is_possible = not self.left_collision_data[0] and not player_is_beyond_screen_right

        self.can_move_left = leftwards_movement_is_possible and not is_decelerating_rightwards
        self.can_move_right = rightwards_movement_is_possible and not is_decelerating_leftwards

    def alter_player_left_edge_if_necessary(self, player_is_beyond_screen_left, player_is_beyond_screen_right):
        &#34;&#34;&#34;Alters the player&#39;s left edge if it is needed: the player has collided with the platform, or has gone beyond the screen&#34;&#34;&#34;

        # Setting the player&#39;s x coordinate if the any of the above conditions were met (collided with platform or beyond screen)
        self.change_attribute_if(player_is_beyond_screen_left, self.set_left_edge, 0)
        self.change_attribute_if(player_is_beyond_screen_right, self.set_left_edge, SCREEN_LENGTH - self.length)

        if self.right_collision_data[0]:
            self.set_left_edge(self.right_collision_data[1].right_edge)

        if self.left_collision_data[0]:
            self.set_left_edge(self.left_collision_data[1].left_edge - self.length)

    def get_deceleration_is_rightwards(self):
        &#34;&#34;&#34;
            Returns:
                boolean: if the deceleration direction is rightwards&#34;&#34;&#34;

        # The deceleration must be going left to stop the player from moving right and vice versa
        return self.deceleration_path.acceleration &lt; 0

    def alter_player_vertical_movement(self):
        &#34;&#34;&#34;Alters the player&#39;s vertical movement so it can&#39;t go through platforms&#34;&#34;&#34;

        player_is_on_platform = self.top_collision_data[0]

        if player_is_on_platform:
            self.set_top_edge(self.top_collision_data[1].top_edge - self.height)

        self.set_is_on_platform(player_is_on_platform, self.top_collision_data[1])

        if self.bottom_collision_data[0]:
            self.run_bottom_edge_collision(self.bottom_collision_data[1].bottom_edge)

    def set_left_edge(self, left_edge):
        &#34;&#34;&#34;Sets the left edge of the player equal to the value provided&#34;&#34;&#34;

        self.left_edge = left_edge

    def change_attribute_if(self, condition, function, value):
        &#34;&#34;&#34;Changes the attribute to the value if &#39;condition()&#39; is True&#34;&#34;&#34;

        if condition:
            function(value)

    def cause_damage(self, amount):
        &#34;&#34;&#34;Damages the player by that amount and also starts the player&#39;s invincibility&#34;&#34;&#34;

        if self.invincibility_event.has_finished():
            self.hit_points_left -= amount
            self.invincibility_event.start()

    def get_topmost_top_edge(self, last_platform, accuracy, min_accuracy):
        &#34;&#34;&#34;Figures out the minimum top edge of the next platform (remember the closer to the top of the screen the lower the top edge)

            Args:
                last_platform (Platform): the platform the player would be jumping from
                accuracy (double): how accurate the player has to be to clear this jump
                min_accuracy (double): the minimum accuracy possible

            Returns:
                double: the max top edge that the next platform could be at that leaves the player &#39;margin_of_error&#39;
        &#34;&#34;&#34;

        topmost_top_edge = last_platform.top_edge - (self.high_jump_height * accuracy) + self.height

        # The absolute max of a platform is the player&#39;s height because the player has to get its bottom_edge on the platform
        # Which would mean the player&#39;s top edge would be 0 also

        if topmost_top_edge &lt;= self.height:
            topmost_top_edge = self.height

        return topmost_top_edge

    def get_distance_to_reach_max_velocity(self):
        &#34;&#34;&#34;
            Returns:
                double: the distance needed for the player to reach max velocity&#34;&#34;&#34;

        time_needed = self.max_horizontal_velocity / self.acceleration_path.acceleration
        return self.acceleration_path.get_distance(time_needed)

    def get_vertical_velocity(self):
        &#34;&#34;&#34;
            Returns:
                float: the velocity of the player at this moment in time
        &#34;&#34;&#34;

        derivative = self.jumping_path.get_piecewise_function().get_derivative()
        return derivative.get_y_coordinate(self.jumping_path.get_current_time())

    def get_vertical_acceleration(self):
        &#34;&#34;&#34;
            Returns:
                float: the acceleration in the vertical direction of the player (falling acceleration)
        &#34;&#34;&#34;

        return PhysicsFunction(self.high_jump_height, self.time_to_high_jump_vertex, 0).get_acceleration()

    # Setters
    def set_total_hit_points(self, total_hit_points):
        self.total_hit_points = total_hit_points

    def set_object_type(self, object_type):
        self.object_type = object_type

    def set_base_left_edge(self, base_left_edge):
        self.base_left_edge = base_left_edge

    def set_base_top_edge(self, base_top_edge):
        self.base_top_edge = base_top_edge

    def set_running_deceleration_time(self, running_deceleration_time):
        self.running_deceleration_time = running_deceleration_time

        self.deceleration_path = PhysicsPath(game_object=self, attribute_modifying=&#34;left_edge&#34;, max_time=self.running_deceleration_time)

    def set_invincibility_total_time(self, invincibility_total_time):
        self.invincibility_total_time = invincibility_total_time

    def set_max_horizontal_velocity(self, max_horizontal_velocity):
        self.max_horizontal_velocity = max_horizontal_velocity

    def set_running_acceleration_time(self, running_acceleration_time):
        self.running_acceleration_time = running_acceleration_time
        self.acceleration_path = PhysicsPath()
        self.acceleration_path.set_acceleration_with_velocity(self.running_acceleration_time, self.max_horizontal_velocity)

    # Jumping
    def update_jumping_path(self):
        &#34;&#34;&#34;Updates the path of the player, so they jump&#34;&#34;&#34;

        self._set_jumping_path_to_high_jump()

    def update_falling_path(self):
        &#34;&#34;&#34;Updates the path of the player, so they fall&#34;&#34;&#34;

        # Finding the normal falling path as defined by its 2 functions (falling, terminal velocity)
        falling_function = PhysicsFunction(self.top_edge + self.high_jump_height, self.time_to_high_jump_vertex, self.top_edge)
        bounded_functions = self.get_jumping_path_bounded_functions([falling_function], [self.time_to_high_jump_vertex])
        self.falling_piecewise_function.set_functions(bounded_functions)

    def update_jump_types(self):
        &#34;&#34;&#34;Updates the variables of the player, so the jump heights work&#34;&#34;&#34;

        # The x coordinate is the time the jump key is held in and the y coordinate is the index of the function
        self.time_to_jump_type = LinearInterpolation(Point(0, 0),
                                                     [Point(self.small_jump_time_held_in, 0),
                                                      Point(self.medium_jump_time_held_in, 1),
                                                      Point(self.high_jump_time_held_in, 2),
                                                      Point(float(&#34;inf&#34;), 2)])

    def set_jumping_path_with_apex(self, time_to_jump_vertex, jump_height, time_from_vertex_to_ground):
        &#34;&#34;&#34;Sets the jumping path of the player, so it has the jump height and time to vertex&#34;&#34;&#34;

        # Finding the jumping path as defined by its 4 functions (upwards, apex, downwards, terminal velocity)
        # Finding the initial variables we need for the calculations below
        jumping_function: PhysicsFunction = self.jumping_piecewise_function.get_functions()[0].get_function()
        time_spent_in_air = self.jumping_path.get_current_time()
        height_jumped = jumping_function.get_displacement(0, time_spent_in_air)
        jump_height_left = jump_height - height_jumped
        time_left = time_to_jump_vertex - time_spent_in_air

        # Calculating the apex variables
        apex_time_left = max_value(self.minimum_jump_deceleration_time, time_left)
        vertex = self.top_edge - jump_height_left
        initial_velocity = self.get_vertical_velocity()

        # Using variables found above to get the functions
        upwards_function = PhysicsFunction()
        upwards_function.set_variables(initial_velocity=initial_velocity, initial_distance=self.top_edge)
        upwards_function.set_acceleration_with_velocity(apex_time_left, -initial_velocity)

        apex_function = Function.get_new_function(lambda x: vertex)  # So the player stays at the vertex
        downwards_function = PhysicsFunction(self.top_edge, time_from_vertex_to_ground, vertex)

        functions = [vertex, upwards_function, apex_function, downwards_function]
        delta_times = [time_to_jump_vertex, self.apex_jump_time, time_from_vertex_to_ground]

        bounded_functions = self.get_jumping_path_bounded_functions(functions, delta_times)
        self.jumping_piecewise_function.set_functions(bounded_functions)

    def _set_jumping_path_to_small_jump(self):
        &#34;&#34;&#34;Sets the jumping path to a small jump&#34;&#34;&#34;

        self.set_jumping_path_with_apex(self.time_to_small_jump_vertex, self.small_jump_height, self.time_from_small_jump_vertex_to_ground)

    def _set_jumping_path_to_medium_jump(self):
        &#34;&#34;&#34;Sets the jumping path to a medium jump&#34;&#34;&#34;

        self.set_jumping_path_with_apex(self.time_to_medium_jump_vertex, self.medium_jump_height, self.time_from_medium_jump_vertex_to_ground)

    def _set_jumping_path_to_high_jump(self):
        &#34;&#34;&#34;Sets the jumping path to a high jump&#34;&#34;&#34;

        self.set_jumping_path_with_apex(self.time_to_high_jump_vertex, self.high_jump_height, self.time_from_high_jump_vertex_to_ground)

    def get_jumping_path_bounded_functions(self, functions, delta_times):
        &#34;&#34;&#34;
            Returns:
                list[BoundedFunction]: the piecewise function with the specified functions and delta times (adds a terminal
                velocity function if the terminal velocity is reached). Assumes the last function is the one which should
                have the velocity clamped at terminal velocity.
        &#34;&#34;&#34;

        # So the player&#39;s velocity is clamped at terminal velocity
        terminal_velocity_function = Function.get_new_function(lambda x: self.terminal_velocity)
        last_function = functions[len(functions) - 1]
        terminal_velocity_delta_time = self.get_terminal_velocity_delta_time(last_function.get_polynomial(),
                                                                             self.terminal_velocity)
        if terminal_velocity_delta_time is not None:
            functions.append(terminal_velocity_function)
            delta_times[len(delta_times) - 1] = terminal_velocity_delta_time
            delta_times.append(float(&#34;inf&#34;))

        return PiecewiseFunction.get_bounded_functions_with_delta_times(functions, delta_times, 0)

    def get_max_time_to_top_edge(self, start_top_edge, new_top_edge):
        &#34;&#34;&#34;
            Returns:
                 double: the max amount of time for the player&#39;s bottom_edge to reach the new y coordinate&#34;&#34;&#34;

        # TODO actually solve this
        return 1.2


    def get_terminal_velocity_delta_time(self, function: Polynomial, terminal_velocity):
        &#34;&#34;&#34;
            Returns:
                float: how long it takes for the player to go from falling to reaching terminal velocity (None if the terminal velocity is never reached)
        &#34;&#34;&#34;

        times_when_terminal_velocity_is_reached = function.get_derivative().get_x_coordinates(terminal_velocity)

        # Only the positive time is wanted (don&#39;t care about other side of polynomial)
        for time in times_when_terminal_velocity_is_reached:
            if time &gt; 0:
                return time

        raise None

    def set_jumping_path_to_default_jump(self):
        &#34;&#34;&#34; Sets the variable &#39;jumping_path&#39; to a path that defines the player&#39;s jump (falling and jumping have different
            gravities to make the game feel better)&#34;&#34;&#34;

        self.update_jumping_path()
        self.jumping_path.set_piecewise_function(self.jumping_piecewise_function)
        self.jumping_path.restart()

    def set_jumping_path_to_falling_path(self):
        &#34;&#34;&#34; Sets the variable &#39;jumping_path&#39; to a path that defines the player&#39;s fall (falling and jumping have different
            gravities to make the game feel better)&#34;&#34;&#34;

        self.update_falling_path()
        self.jumping_path.set_piecewise_function(self.falling_piecewise_function)
        self.jumping_path.restart()

    def run_jump_type(self):
        &#34;&#34;&#34;Runs a different jump type (small, medium, or large) depending on how long the key was held in&#34;&#34;&#34;

        # In this case the y coordinate is the function that should be called
        self.time_to_jump_type.get_y_coordinate(self.jump_key_held_in_time)()
        self.jump_key_held_in_time = -1

    def set_coyote_time(self, coyote_time):
        self.coyote_time = coyote_time

    def set_terminal_velocity(self, terminal_velocity):
        self.terminal_velocity = terminal_velocity

    def set_jump_buffer_time(self, jump_buffer_time):
        self.jump_buffer_time = jump_buffer_time

    def set_apex_jump_time(self, apex_jump_time):
        self.apex_jump_time = apex_jump_time

    def set_apex_horizontal_velocity_multiplier(self, apex_horizontal_velocity_multiplier):
        self.apex_horizontal_velocity_multiplier = apex_horizontal_velocity_multiplier

    def set_time_to_high_jump_vertex(self, variable):
        self.time_to_high_jump_vertex = variable
        self.update_jump_types()

    def set_time_from_high_jump_vertex_to_ground(self, variable):
        self.time_from_high_jump_vertex_to_ground = variable
        self.update_jump_types()

    def set_high_jump_height(self, variable):
        self.high_jump_height = variable
        self.update_jump_types()

    def set_high_jump_time_held_in(self, variable):
        self.high_jump_time_held_in = variable
        self.update_jump_types()

    def set_time_to_medium_jump_vertex(self, variable):
        self.time_to_medium_jump_vertex = variable
        self.update_jump_types()

    def set_time_from_medium_jump_vertex_to_ground(self, variable):
        self.time_from_medium_jump_vertex_to_ground = variable
        self.update_jump_types()

    def set_medium_jump_height(self, variable):
        self.medium_jump_height = variable
        self.update_jump_types()

    def set_medium_jump_time_held_in(self, variable):
        self.medium_jump_time_held_in = variable
        self.update_jump_types()

    def set_time_to_small_jump_vertex(self, variable):
        self.time_to_small_jump_vertex = variable
        self.update_jump_types()

    def set_time_from_small_jump_vertex_to_ground(self, variable):
        self.time_from_small_jump_vertex_to_ground = variable
        self.update_jump_types()

    def set_small_jump_height(self, variable):
        self.small_jump_height = variable
        self.update_jump_types()

    def set_small_jump_time_held_in(self, variable):
        self.small_jump_time_held_in = variable
        self.update_jump_types()

    def set_base_coordinates(self, base_left_edge, base_top_edge):
        &#34;&#34;&#34;Sets the base coordinates of the player&#34;&#34;&#34;

        self.base_left_edge = base_left_edge
        self.base_top_edge = base_top_edge</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="game_qu.platformer.player.Player"><code class="flex name class">
<span>class <span class="ident">Player</span></span>
<span>(</span><span>left_key, right_key, jump_key, down_key, attack_key)</span>
</code></dt>
<dd>
<div class="desc"><p>The way that people can play the game (accepts user input to move)</p>
<p>Initializes the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player(WeaponUser):
    &#34;&#34;&#34;The way that people can play the game (accepts user input to move)&#34;&#34;&#34;

    all_paths_and_events = []

    # Modifiable Variables
    length = VelocityCalculator.get_dimension(SCREEN_LENGTH, 5)
    height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 15)

    total_hit_points = 50
    object_type = &#34;Player&#34;

    # So you can control all the jump movements (it feels better if there is different jump arcs for up and down)
    apex_jump_time = 0.1
    apex_horizontal_velocity_multiplier = 1.25
    coyote_time = 0.2
    terminal_velocity = VelocityCalculator.get_velocity(SCREEN_LENGTH, 1500)
    jump_buffer_time = 0.5

    # Variable Jump Heights
    time_to_high_jump_vertex = 0.55
    time_from_high_jump_vertex_to_ground = 0.35
    high_jump_height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 30)
    high_jump_time_held_in = 0.35

    time_to_medium_jump_vertex = 0.4
    time_from_medium_jump_vertex_to_ground = 0.2
    medium_jump_height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 20)
    medium_jump_time_held_in = 0.2

    time_to_small_jump_vertex = 0.3
    time_from_small_jump_vertex_to_ground = 0.2
    small_jump_height = VelocityCalculator.get_dimension(SCREEN_HEIGHT, 10)
    small_jump_time_held_in = 0.1

    running_deceleration_time = 0.3
    invincibility_total_time = 1
    max_horizontal_velocity = VelocityCalculator.get_velocity(SCREEN_LENGTH, 500)
    running_acceleration_time = 0.2

    minimum_jump_deceleration_time = 0.1

    # Miscellaneous
    hit_points_left = total_hit_points
    jumping_path = None
    deceleration_path = None
    acceleration_path = None
    current_velocity = 0
    initial_upwards_velocity = 0
    invincibility_event = None
    platform_is_on = None
    last_platform_was_on = None
    # So the player can be run and side scrolling can be done before the rendering (otherwise it doesn&#39;t look smooth)
    is_runnable = False
    has_jumped = False
    jumping_piecewise_function = None
    falling_piecewise_function = None
    time_to_jump_type = None
    coyote_timed_event = None
    jump_buffer_timed_event = None
    base_left_edge = -1
    base_top_edge = -1
    jump_key_held_in_time = -1

    # Booleans
    can_move_down = False
    can_move_left = False
    can_move_right = False
    is_on_platform = True
    is_facing_right = True

    # Keys
    left_key = None
    right_key = None
    jump_key = None
    down_key = None
    attack_key = None

    def __init__(self, left_key, right_key, jump_key, down_key, attack_key):
        &#34;&#34;&#34;Initializes the object&#34;&#34;&#34;

        super().__init__(&#34;&#34;)

        self.left_key, self.right_key, self.jump_key = left_key, right_key, jump_key
        self.down_key, self.attack_key = down_key, attack_key
        self.invincibility_event = TimedEvent(self.invincibility_total_time, False)
        self.coyote_timed_event = TimedEvent(self.coyote_time, False)
        self.jump_buffer_timed_event = TimedEvent(self.jump_buffer_time, False)

        self.create_paths()
        self.all_paths_and_events = [self.jumping_path, self.deceleration_path, self.acceleration_path]
        self.jumping_functions = [self._set_jumping_path_to_small_jump, self._set_jumping_path_to_medium_jump,
                                  self._set_jumping_path_to_high_jump]

    def create_paths(self):
        &#34;&#34;&#34;Creates all the paths for the player: jumping_path, decelerating_path, etc.&#34;&#34;&#34;

        self.jumping_piecewise_function = PiecewiseFunction([])
        self.falling_piecewise_function = PiecewiseFunction([])

        self.jumping_path = PiecewiseFollowablePath(self.jumping_piecewise_function, game_object=self, attribute_modifying=&#34;top_edge&#34;)

        self.set_running_acceleration_time(self.running_acceleration_time)
        self.set_running_deceleration_time(self.running_deceleration_time)

    def run(self):
        &#34;&#34;&#34;Runs all the code that is necessary for the player to work properly&#34;&#34;&#34;

        self.invincibility_event.run(self.invincibility_event.current_time &gt; self.invincibility_event.time_needed, False)
        self.run_horizontal_movement()
        self.run_vertical_movement()

    def run_vertical_movement(self):
        &#34;&#34;&#34;Runs all the vertical movement (mostly jumping)&#34;&#34;&#34;

        if game_button_is_clicked(self.jump_key):
            if self.is_on_platform:
                self.jump()

            if self.coyote_timed_event.is_running():
                self.jump()
                self.coyote_timed_event.reset()

        if game_button_has_been_released(self.jump_key):
            self.jump_key_held_in_time = get_time_of_game_button_being_held_in(self.jump_key)

            if self.has_jumped:
                self.run_jump_type(self.jump_key_held_in_time)

        if self.top_edge &lt;= 0:
            self.run_bottom_edge_collision(0)

        self.jumping_path.run(is_changing_attribute=True)

    def run_horizontal_movement(self):
        &#34;&#34;&#34;Runs all the code for horizontal movement: acceleration, deceleration, etc.&#34;&#34;&#34;

        self.is_facing_right = True if game_button_is_pressed(self.right_key) else self.is_facing_right
        self.is_facing_right = False if game_button_is_pressed(self.left_key) else self.is_facing_right

        self.run_deceleration()
        self.run_acceleration()

        GameMovement.player_horizontal_movement(self, self.current_velocity, self.left_key, self.right_key)

    def run_acceleration(self):
        &#34;&#34;&#34;Runs all the code for acceleration (so the player comes to the max velocity)&#34;&#34;&#34;

        if self.player_movement_direction_is_same_as_deceleration():
            self.continue_acceleration_after_partial_deceleration()

        if self.deceleration_path.has_finished():
            GameMovement.run_acceleration(self, game_button_is_pressed(self.left_key) or game_button_is_pressed(self.right_key), self.acceleration_path, self.max_horizontal_velocity)

        if not self.acceleration_direction_is_possible(self.acceleration_path.acceleration &gt; 0):
            self.acceleration_path.reset()

    def run_deceleration(self):
        &#34;&#34;&#34;Runs all the code for decelerating (so the player comes to a stop slowly)&#34;&#34;&#34;

        deceleration_direction_is_possible = self.acceleration_direction_is_possible(self.get_deceleration_is_rightwards())

        # Meaning no outside force has stopped the deceleration like platforms or screen limits
        deceleration_has_manually_stopped = self.deceleration_path.has_finished() or self.player_movement_direction_is_same_as_deceleration()
        can_decelerate = deceleration_direction_is_possible and not deceleration_has_manually_stopped

        if can_decelerate:
            self.deceleration_path.run(False, False, is_changing_coordinates=False)
            self.left_edge += self.deceleration_path.get_total_displacement()

        else:
            self.deceleration_path.reset()

        if self.horizontal_movement_has_stopped():
            self.decelerate_player(game_button_has_been_released(self.right_key))

    def horizontal_movement_has_stopped(self):
        &#34;&#34;&#34;
            Returns:
                boolean: if horizontal movement has stopped (player has released a movement key)&#34;&#34;&#34;

        return game_button_has_been_released(self.right_key) or game_button_has_been_released(self.left_key)

    def acceleration_direction_is_possible(self, movement_is_rightwards):
        &#34;&#34;&#34;
            Returns:
                boolean: whether the path acceleration&#39;s movement is not possible because of either the screen or a platform
                | This is used for both the acceleration_path and deceleration_path. Figures out if the direction of acceleration
                is possible (if it can&#39;t move right it can&#39;t accelerate right&#34;&#34;&#34;

        return self.can_move_right if movement_is_rightwards else self.can_move_left

    def set_is_on_platform(self, is_on_platform, platform_is_on):
        &#34;&#34;&#34;Sets the player&#39;s &#39;is_on_platform&#39; attribute&#34;&#34;&#34;

        if not self.is_on_platform and is_on_platform:
            self.jumping_path.reset()

        if self.is_on_platform and not is_on_platform and not self.has_jumped:
            self.set_jumping_path_to_falling_path()

        if self.jump_buffer_timed_event.is_running():
            self.jump()
            self.jump_buffer_timed_event.reset()

        self.last_platform_was_on = platform_is_on if is_on_platform else self.last_platform_was_on
        self.platform_is_on = platform_is_on if is_on_platform else None
        self.is_on_platform = is_on_platform

    def reset(self):
        &#34;&#34;&#34;Resets the player back to the start of the game&#34;&#34;&#34;

        self.left_edge = self.base_left_edge
        self.top_edge = self.base_top_edge

        self.weapon.reset()
        self.run_respawning()  # Resetting from the game ending and respawning has a lot in similarity

    def run_respawning(self):
        &#34;&#34;&#34;Makes the player respawn (resets most things)&#34;&#34;&#34;

        self.is_on_platform = True
        self.hit_points_left = self.total_hit_points
        self.invincibility_event.reset()

        # Resetting the direction the player can move
        self.can_move_left, self.can_move_right, self.can_move_down = False, False, False

        for path_or_event in self.all_paths_and_events:
            path_or_event.reset()

    def jump(self):
        &#34;&#34;&#34;Makes the player jump&#34;&#34;&#34;

        self.jumping_path.start()
        self.set_jumping_path_to_default_jump()
        self.has_jumped = True

        if self.jump_key_held_in_time != -1:
            self.run_jump_type()

    def decelerate_player(self, is_moving_right):
        &#34;&#34;&#34;Makes the player decelerate by calling deceleration_path.start()&#34;&#34;&#34;

        self.deceleration_path.initial_distance = self.left_edge
        self.deceleration_path.initial_velocity = self.current_velocity if is_moving_right else -self.current_velocity

        # If the player is not at maximum velocity it shouldn&#39;t take as long to decelerate
        fraction_of_max_velocity = self.current_velocity / self.max_horizontal_velocity
        time_needed = self.running_deceleration_time * fraction_of_max_velocity

        # Gotten using math; Makes the player stop in the amount of time &#39;self.running_deceleration_time&#39;
        self.deceleration_path.acceleration = -self.deceleration_path.initial_velocity / time_needed

        self.deceleration_path.start()
        self.deceleration_path.max_time = time_needed

    def player_movement_direction_is_same_as_deceleration(self):
        &#34;&#34;&#34;
            Returns:
                boolean: if the direction the player is moving is equal to the deceleration&#34;&#34;&#34;

        deceleration_direction_is_rightwards = self.deceleration_path.acceleration &lt; 0

        # Looking at both the leftwards and rightwards movement: movement and deceleration have both to be leftwards or rightwards
        rightwards_movement_is_same_as_deceleration = deceleration_direction_is_rightwards and game_button_is_pressed(self.right_key)
        leftwards_movement_is_same_as_deceleration = not deceleration_direction_is_rightwards and game_button_is_pressed(self.left_key)

        return leftwards_movement_is_same_as_deceleration or rightwards_movement_is_same_as_deceleration

    def continue_acceleration_after_partial_deceleration(self):
        &#34;&#34;&#34;Updates the time of the acceleration_path, so that it will pick up at the velocity where the deceleration ended at&#34;&#34;&#34;

        current_velocity = self.deceleration_path.get_velocity_using_time(self.deceleration_path.current_time)
        self.acceleration_path.start()

        # Figuring out the time to get to that velocity, so the player can continue to accelerate to the max velocity
        self.acceleration_path.current_time = sqrt(abs(current_velocity) / self.acceleration_path.acceleration)

    def run_bottom_edge_collision(self, top_edge):
        &#34;&#34;&#34;Runs what should happen after a bottom collision (the player should rebound off of it)&#34;&#34;&#34;

        velocity = self.get_vertical_velocity()
        falling_function = PhysicsFunction(self.high_jump_height, self.time_to_high_jump_vertex, self.top_edge)
        falling_function.set_initial_velocity(velocity)
        functions = self.get_jumping_path_bounded_functions([falling_function],
                                                            [self.time_from_high_jump_vertex_to_ground])

        self.falling_piecewise_function.set_functions(functions)
        self.set_jumping_path_to_falling_path()

        self.jumping_path.reset()
        self.top_edge = top_edge

    def get_horizontal_velocity(self):
        &#34;&#34;&#34;
            Returns:
                double: the current velocity of the player&#34;&#34;&#34;

        # The velocity of the player is two-fold: either it has its usual velocity when it is not decelerating, or it has
        # The velocity from the deceleration. The deceleration_path does not affect the current_velocity because it was
        # Easier not to do that, so it does not do it that way
        deceleration_velocity = self.deceleration_path.get_velocity_using_time(self.deceleration_path.current_time)
        normal_velocity = self.current_velocity

        return normal_velocity if self.deceleration_path.has_finished() else deceleration_velocity

    # Collision Stuff
    def run_inanimate_object_collision(self, inanimate_object, index_of_sub_component):
        &#34;&#34;&#34;Runs what should happen when the player collides with an inanimate object&#34;&#34;&#34;

        if index_of_sub_component == self.index_of_user:
            self.update_platform_collision_data(inanimate_object)

        if index_of_sub_component != self.index_of_user:
            self.weapon.run_inanimate_object_collision(inanimate_object, index_of_sub_component - self.weapon_index_offset)

    def run_collisions(self):
        &#34;&#34;&#34;Runs what should happen based on what got stored in the collision data&#34;&#34;&#34;

        # The player should only act upon the collision data if there was stuff in the History Keeper because if there wasn&#39;t
        # Then the game is automatically going to say it was not a collision (top, left, right, bottom)
        if HistoryKeeper.get_last(self.name) is not None:
            self.alter_player_horizontal_movement()
            self.alter_player_vertical_movement()

    def alter_player_horizontal_movement(self):
        &#34;&#34;&#34;Alters the player&#39;s horizontal movement so it stays within the screen and is not touching the platforms&#34;&#34;&#34;

        player_is_beyond_screen_left = is_beyond_screen_left(self.left_edge)
        player_is_beyond_screen_right = is_beyond_screen_right(self.right_edge)

        self.alter_player_horizontal_movement_booleans(player_is_beyond_screen_left, player_is_beyond_screen_right)
        self.alter_player_left_edge_if_necessary(player_is_beyond_screen_left, player_is_beyond_screen_right)

    def alter_player_horizontal_movement_booleans(self, player_is_beyond_screen_left, player_is_beyond_screen_right):
        &#34;&#34;&#34;Alters the player&#39;s horizontal movement direction boolean attributes: &#39;can_move_left&#39; and &#39;can_move_right&#39;&#34;&#34;&#34;

        is_decelerating_rightwards = not self.deceleration_path.has_finished() and self.get_deceleration_is_rightwards()
        is_decelerating_leftwards = not self.deceleration_path.has_finished() and not self.get_deceleration_is_rightwards()

        # Possible relating to everything but the deceleration
        leftwards_movement_is_possible = not self.right_collision_data[0] and not player_is_beyond_screen_left
        rightwards_movement_is_possible = not self.left_collision_data[0] and not player_is_beyond_screen_right

        self.can_move_left = leftwards_movement_is_possible and not is_decelerating_rightwards
        self.can_move_right = rightwards_movement_is_possible and not is_decelerating_leftwards

    def alter_player_left_edge_if_necessary(self, player_is_beyond_screen_left, player_is_beyond_screen_right):
        &#34;&#34;&#34;Alters the player&#39;s left edge if it is needed: the player has collided with the platform, or has gone beyond the screen&#34;&#34;&#34;

        # Setting the player&#39;s x coordinate if the any of the above conditions were met (collided with platform or beyond screen)
        self.change_attribute_if(player_is_beyond_screen_left, self.set_left_edge, 0)
        self.change_attribute_if(player_is_beyond_screen_right, self.set_left_edge, SCREEN_LENGTH - self.length)

        if self.right_collision_data[0]:
            self.set_left_edge(self.right_collision_data[1].right_edge)

        if self.left_collision_data[0]:
            self.set_left_edge(self.left_collision_data[1].left_edge - self.length)

    def get_deceleration_is_rightwards(self):
        &#34;&#34;&#34;
            Returns:
                boolean: if the deceleration direction is rightwards&#34;&#34;&#34;

        # The deceleration must be going left to stop the player from moving right and vice versa
        return self.deceleration_path.acceleration &lt; 0

    def alter_player_vertical_movement(self):
        &#34;&#34;&#34;Alters the player&#39;s vertical movement so it can&#39;t go through platforms&#34;&#34;&#34;

        player_is_on_platform = self.top_collision_data[0]

        if player_is_on_platform:
            self.set_top_edge(self.top_collision_data[1].top_edge - self.height)

        self.set_is_on_platform(player_is_on_platform, self.top_collision_data[1])

        if self.bottom_collision_data[0]:
            self.run_bottom_edge_collision(self.bottom_collision_data[1].bottom_edge)

    def set_left_edge(self, left_edge):
        &#34;&#34;&#34;Sets the left edge of the player equal to the value provided&#34;&#34;&#34;

        self.left_edge = left_edge

    def change_attribute_if(self, condition, function, value):
        &#34;&#34;&#34;Changes the attribute to the value if &#39;condition()&#39; is True&#34;&#34;&#34;

        if condition:
            function(value)

    def cause_damage(self, amount):
        &#34;&#34;&#34;Damages the player by that amount and also starts the player&#39;s invincibility&#34;&#34;&#34;

        if self.invincibility_event.has_finished():
            self.hit_points_left -= amount
            self.invincibility_event.start()

    def get_topmost_top_edge(self, last_platform, accuracy, min_accuracy):
        &#34;&#34;&#34;Figures out the minimum top edge of the next platform (remember the closer to the top of the screen the lower the top edge)

            Args:
                last_platform (Platform): the platform the player would be jumping from
                accuracy (double): how accurate the player has to be to clear this jump
                min_accuracy (double): the minimum accuracy possible

            Returns:
                double: the max top edge that the next platform could be at that leaves the player &#39;margin_of_error&#39;
        &#34;&#34;&#34;

        topmost_top_edge = last_platform.top_edge - (self.high_jump_height * accuracy) + self.height

        # The absolute max of a platform is the player&#39;s height because the player has to get its bottom_edge on the platform
        # Which would mean the player&#39;s top edge would be 0 also

        if topmost_top_edge &lt;= self.height:
            topmost_top_edge = self.height

        return topmost_top_edge

    def get_distance_to_reach_max_velocity(self):
        &#34;&#34;&#34;
            Returns:
                double: the distance needed for the player to reach max velocity&#34;&#34;&#34;

        time_needed = self.max_horizontal_velocity / self.acceleration_path.acceleration
        return self.acceleration_path.get_distance(time_needed)

    def get_vertical_velocity(self):
        &#34;&#34;&#34;
            Returns:
                float: the velocity of the player at this moment in time
        &#34;&#34;&#34;

        derivative = self.jumping_path.get_piecewise_function().get_derivative()
        return derivative.get_y_coordinate(self.jumping_path.get_current_time())

    def get_vertical_acceleration(self):
        &#34;&#34;&#34;
            Returns:
                float: the acceleration in the vertical direction of the player (falling acceleration)
        &#34;&#34;&#34;

        return PhysicsFunction(self.high_jump_height, self.time_to_high_jump_vertex, 0).get_acceleration()

    # Setters
    def set_total_hit_points(self, total_hit_points):
        self.total_hit_points = total_hit_points

    def set_object_type(self, object_type):
        self.object_type = object_type

    def set_base_left_edge(self, base_left_edge):
        self.base_left_edge = base_left_edge

    def set_base_top_edge(self, base_top_edge):
        self.base_top_edge = base_top_edge

    def set_running_deceleration_time(self, running_deceleration_time):
        self.running_deceleration_time = running_deceleration_time

        self.deceleration_path = PhysicsPath(game_object=self, attribute_modifying=&#34;left_edge&#34;, max_time=self.running_deceleration_time)

    def set_invincibility_total_time(self, invincibility_total_time):
        self.invincibility_total_time = invincibility_total_time

    def set_max_horizontal_velocity(self, max_horizontal_velocity):
        self.max_horizontal_velocity = max_horizontal_velocity

    def set_running_acceleration_time(self, running_acceleration_time):
        self.running_acceleration_time = running_acceleration_time
        self.acceleration_path = PhysicsPath()
        self.acceleration_path.set_acceleration_with_velocity(self.running_acceleration_time, self.max_horizontal_velocity)

    # Jumping
    def update_jumping_path(self):
        &#34;&#34;&#34;Updates the path of the player, so they jump&#34;&#34;&#34;

        self._set_jumping_path_to_high_jump()

    def update_falling_path(self):
        &#34;&#34;&#34;Updates the path of the player, so they fall&#34;&#34;&#34;

        # Finding the normal falling path as defined by its 2 functions (falling, terminal velocity)
        falling_function = PhysicsFunction(self.top_edge + self.high_jump_height, self.time_to_high_jump_vertex, self.top_edge)
        bounded_functions = self.get_jumping_path_bounded_functions([falling_function], [self.time_to_high_jump_vertex])
        self.falling_piecewise_function.set_functions(bounded_functions)

    def update_jump_types(self):
        &#34;&#34;&#34;Updates the variables of the player, so the jump heights work&#34;&#34;&#34;

        # The x coordinate is the time the jump key is held in and the y coordinate is the index of the function
        self.time_to_jump_type = LinearInterpolation(Point(0, 0),
                                                     [Point(self.small_jump_time_held_in, 0),
                                                      Point(self.medium_jump_time_held_in, 1),
                                                      Point(self.high_jump_time_held_in, 2),
                                                      Point(float(&#34;inf&#34;), 2)])

    def set_jumping_path_with_apex(self, time_to_jump_vertex, jump_height, time_from_vertex_to_ground):
        &#34;&#34;&#34;Sets the jumping path of the player, so it has the jump height and time to vertex&#34;&#34;&#34;

        # Finding the jumping path as defined by its 4 functions (upwards, apex, downwards, terminal velocity)
        # Finding the initial variables we need for the calculations below
        jumping_function: PhysicsFunction = self.jumping_piecewise_function.get_functions()[0].get_function()
        time_spent_in_air = self.jumping_path.get_current_time()
        height_jumped = jumping_function.get_displacement(0, time_spent_in_air)
        jump_height_left = jump_height - height_jumped
        time_left = time_to_jump_vertex - time_spent_in_air

        # Calculating the apex variables
        apex_time_left = max_value(self.minimum_jump_deceleration_time, time_left)
        vertex = self.top_edge - jump_height_left
        initial_velocity = self.get_vertical_velocity()

        # Using variables found above to get the functions
        upwards_function = PhysicsFunction()
        upwards_function.set_variables(initial_velocity=initial_velocity, initial_distance=self.top_edge)
        upwards_function.set_acceleration_with_velocity(apex_time_left, -initial_velocity)

        apex_function = Function.get_new_function(lambda x: vertex)  # So the player stays at the vertex
        downwards_function = PhysicsFunction(self.top_edge, time_from_vertex_to_ground, vertex)

        functions = [vertex, upwards_function, apex_function, downwards_function]
        delta_times = [time_to_jump_vertex, self.apex_jump_time, time_from_vertex_to_ground]

        bounded_functions = self.get_jumping_path_bounded_functions(functions, delta_times)
        self.jumping_piecewise_function.set_functions(bounded_functions)

    def _set_jumping_path_to_small_jump(self):
        &#34;&#34;&#34;Sets the jumping path to a small jump&#34;&#34;&#34;

        self.set_jumping_path_with_apex(self.time_to_small_jump_vertex, self.small_jump_height, self.time_from_small_jump_vertex_to_ground)

    def _set_jumping_path_to_medium_jump(self):
        &#34;&#34;&#34;Sets the jumping path to a medium jump&#34;&#34;&#34;

        self.set_jumping_path_with_apex(self.time_to_medium_jump_vertex, self.medium_jump_height, self.time_from_medium_jump_vertex_to_ground)

    def _set_jumping_path_to_high_jump(self):
        &#34;&#34;&#34;Sets the jumping path to a high jump&#34;&#34;&#34;

        self.set_jumping_path_with_apex(self.time_to_high_jump_vertex, self.high_jump_height, self.time_from_high_jump_vertex_to_ground)

    def get_jumping_path_bounded_functions(self, functions, delta_times):
        &#34;&#34;&#34;
            Returns:
                list[BoundedFunction]: the piecewise function with the specified functions and delta times (adds a terminal
                velocity function if the terminal velocity is reached). Assumes the last function is the one which should
                have the velocity clamped at terminal velocity.
        &#34;&#34;&#34;

        # So the player&#39;s velocity is clamped at terminal velocity
        terminal_velocity_function = Function.get_new_function(lambda x: self.terminal_velocity)
        last_function = functions[len(functions) - 1]
        terminal_velocity_delta_time = self.get_terminal_velocity_delta_time(last_function.get_polynomial(),
                                                                             self.terminal_velocity)
        if terminal_velocity_delta_time is not None:
            functions.append(terminal_velocity_function)
            delta_times[len(delta_times) - 1] = terminal_velocity_delta_time
            delta_times.append(float(&#34;inf&#34;))

        return PiecewiseFunction.get_bounded_functions_with_delta_times(functions, delta_times, 0)

    def get_max_time_to_top_edge(self, start_top_edge, new_top_edge):
        &#34;&#34;&#34;
            Returns:
                 double: the max amount of time for the player&#39;s bottom_edge to reach the new y coordinate&#34;&#34;&#34;

        # TODO actually solve this
        return 1.2


    def get_terminal_velocity_delta_time(self, function: Polynomial, terminal_velocity):
        &#34;&#34;&#34;
            Returns:
                float: how long it takes for the player to go from falling to reaching terminal velocity (None if the terminal velocity is never reached)
        &#34;&#34;&#34;

        times_when_terminal_velocity_is_reached = function.get_derivative().get_x_coordinates(terminal_velocity)

        # Only the positive time is wanted (don&#39;t care about other side of polynomial)
        for time in times_when_terminal_velocity_is_reached:
            if time &gt; 0:
                return time

        raise None

    def set_jumping_path_to_default_jump(self):
        &#34;&#34;&#34; Sets the variable &#39;jumping_path&#39; to a path that defines the player&#39;s jump (falling and jumping have different
            gravities to make the game feel better)&#34;&#34;&#34;

        self.update_jumping_path()
        self.jumping_path.set_piecewise_function(self.jumping_piecewise_function)
        self.jumping_path.restart()

    def set_jumping_path_to_falling_path(self):
        &#34;&#34;&#34; Sets the variable &#39;jumping_path&#39; to a path that defines the player&#39;s fall (falling and jumping have different
            gravities to make the game feel better)&#34;&#34;&#34;

        self.update_falling_path()
        self.jumping_path.set_piecewise_function(self.falling_piecewise_function)
        self.jumping_path.restart()

    def run_jump_type(self):
        &#34;&#34;&#34;Runs a different jump type (small, medium, or large) depending on how long the key was held in&#34;&#34;&#34;

        # In this case the y coordinate is the function that should be called
        self.time_to_jump_type.get_y_coordinate(self.jump_key_held_in_time)()
        self.jump_key_held_in_time = -1

    def set_coyote_time(self, coyote_time):
        self.coyote_time = coyote_time

    def set_terminal_velocity(self, terminal_velocity):
        self.terminal_velocity = terminal_velocity

    def set_jump_buffer_time(self, jump_buffer_time):
        self.jump_buffer_time = jump_buffer_time

    def set_apex_jump_time(self, apex_jump_time):
        self.apex_jump_time = apex_jump_time

    def set_apex_horizontal_velocity_multiplier(self, apex_horizontal_velocity_multiplier):
        self.apex_horizontal_velocity_multiplier = apex_horizontal_velocity_multiplier

    def set_time_to_high_jump_vertex(self, variable):
        self.time_to_high_jump_vertex = variable
        self.update_jump_types()

    def set_time_from_high_jump_vertex_to_ground(self, variable):
        self.time_from_high_jump_vertex_to_ground = variable
        self.update_jump_types()

    def set_high_jump_height(self, variable):
        self.high_jump_height = variable
        self.update_jump_types()

    def set_high_jump_time_held_in(self, variable):
        self.high_jump_time_held_in = variable
        self.update_jump_types()

    def set_time_to_medium_jump_vertex(self, variable):
        self.time_to_medium_jump_vertex = variable
        self.update_jump_types()

    def set_time_from_medium_jump_vertex_to_ground(self, variable):
        self.time_from_medium_jump_vertex_to_ground = variable
        self.update_jump_types()

    def set_medium_jump_height(self, variable):
        self.medium_jump_height = variable
        self.update_jump_types()

    def set_medium_jump_time_held_in(self, variable):
        self.medium_jump_time_held_in = variable
        self.update_jump_types()

    def set_time_to_small_jump_vertex(self, variable):
        self.time_to_small_jump_vertex = variable
        self.update_jump_types()

    def set_time_from_small_jump_vertex_to_ground(self, variable):
        self.time_from_small_jump_vertex_to_ground = variable
        self.update_jump_types()

    def set_small_jump_height(self, variable):
        self.small_jump_height = variable
        self.update_jump_types()

    def set_small_jump_time_held_in(self, variable):
        self.small_jump_time_held_in = variable
        self.update_jump_types()

    def set_base_coordinates(self, base_left_edge, base_top_edge):
        &#34;&#34;&#34;Sets the base coordinates of the player&#34;&#34;&#34;

        self.base_left_edge = base_left_edge
        self.base_top_edge = base_top_edge</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="game_qu.platformer.weapon_user.WeaponUser" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser">WeaponUser</a></li>
<li><a title="game_qu.platformer.game_object.GameObject" href="game_object.html#game_qu.platformer.game_object.GameObject">GameObject</a></li>
<li><a title="game_qu.gui_components.component.Component" href="../gui_components/component.html#game_qu.gui_components.component.Component">Component</a></li>
<li><a title="game_qu.gui_components.dimensions.Dimensions" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions">Dimensions</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Game-Qu.src.game_qu.getting_started.platforming game (example game).SimplePlayer" href="../../Game-Qu/src/game_qu/getting_started/platforming game (example game).html#Game-Qu.src.game_qu.getting_started.platforming game (example game).SimplePlayer">SimplePlayer</a></li>
<li><a title="game_qu.getting_started.platforming game (example game).SimplePlayer" href="../getting_started/platforming game (example game).html#game_qu.getting_started.platforming game (example game).SimplePlayer">SimplePlayer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="game_qu.platformer.player.Player.acceleration_path"><code class="name">var <span class="ident">acceleration_path</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.all_paths_and_events"><code class="name">var <span class="ident">all_paths_and_events</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.apex_horizontal_velocity_multiplier"><code class="name">var <span class="ident">apex_horizontal_velocity_multiplier</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.apex_jump_time"><code class="name">var <span class="ident">apex_jump_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.attack_key"><code class="name">var <span class="ident">attack_key</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.base_left_edge"><code class="name">var <span class="ident">base_left_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.base_top_edge"><code class="name">var <span class="ident">base_top_edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.can_move_down"><code class="name">var <span class="ident">can_move_down</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.can_move_left"><code class="name">var <span class="ident">can_move_left</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.can_move_right"><code class="name">var <span class="ident">can_move_right</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.coyote_time"><code class="name">var <span class="ident">coyote_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.coyote_timed_event"><code class="name">var <span class="ident">coyote_timed_event</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.current_velocity"><code class="name">var <span class="ident">current_velocity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.deceleration_path"><code class="name">var <span class="ident">deceleration_path</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.down_key"><code class="name">var <span class="ident">down_key</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.falling_piecewise_function"><code class="name">var <span class="ident">falling_piecewise_function</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.has_jumped"><code class="name">var <span class="ident">has_jumped</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.high_jump_height"><code class="name">var <span class="ident">high_jump_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.high_jump_time_held_in"><code class="name">var <span class="ident">high_jump_time_held_in</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.hit_points_left"><code class="name">var <span class="ident">hit_points_left</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.initial_upwards_velocity"><code class="name">var <span class="ident">initial_upwards_velocity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.invincibility_event"><code class="name">var <span class="ident">invincibility_event</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.invincibility_total_time"><code class="name">var <span class="ident">invincibility_total_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.is_facing_right"><code class="name">var <span class="ident">is_facing_right</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.is_on_platform"><code class="name">var <span class="ident">is_on_platform</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.is_runnable"><code class="name">var <span class="ident">is_runnable</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.jump_buffer_time"><code class="name">var <span class="ident">jump_buffer_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.jump_buffer_timed_event"><code class="name">var <span class="ident">jump_buffer_timed_event</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.jump_key"><code class="name">var <span class="ident">jump_key</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.jump_key_held_in_time"><code class="name">var <span class="ident">jump_key_held_in_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.jumping_path"><code class="name">var <span class="ident">jumping_path</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.jumping_piecewise_function"><code class="name">var <span class="ident">jumping_piecewise_function</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.last_platform_was_on"><code class="name">var <span class="ident">last_platform_was_on</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.left_key"><code class="name">var <span class="ident">left_key</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.max_horizontal_velocity"><code class="name">var <span class="ident">max_horizontal_velocity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.medium_jump_height"><code class="name">var <span class="ident">medium_jump_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.medium_jump_time_held_in"><code class="name">var <span class="ident">medium_jump_time_held_in</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.minimum_jump_deceleration_time"><code class="name">var <span class="ident">minimum_jump_deceleration_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.object_type"><code class="name">var <span class="ident">object_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.platform_is_on"><code class="name">var <span class="ident">platform_is_on</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.right_key"><code class="name">var <span class="ident">right_key</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.running_acceleration_time"><code class="name">var <span class="ident">running_acceleration_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.running_deceleration_time"><code class="name">var <span class="ident">running_deceleration_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.small_jump_height"><code class="name">var <span class="ident">small_jump_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.small_jump_time_held_in"><code class="name">var <span class="ident">small_jump_time_held_in</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.terminal_velocity"><code class="name">var <span class="ident">terminal_velocity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.time_from_high_jump_vertex_to_ground"><code class="name">var <span class="ident">time_from_high_jump_vertex_to_ground</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.time_from_medium_jump_vertex_to_ground"><code class="name">var <span class="ident">time_from_medium_jump_vertex_to_ground</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.time_from_small_jump_vertex_to_ground"><code class="name">var <span class="ident">time_from_small_jump_vertex_to_ground</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.time_to_high_jump_vertex"><code class="name">var <span class="ident">time_to_high_jump_vertex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.time_to_jump_type"><code class="name">var <span class="ident">time_to_jump_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.time_to_medium_jump_vertex"><code class="name">var <span class="ident">time_to_medium_jump_vertex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.time_to_small_jump_vertex"><code class="name">var <span class="ident">time_to_small_jump_vertex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.platformer.player.Player.total_hit_points"><code class="name">var <span class="ident">total_hit_points</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="game_qu.platformer.player.Player.acceleration_direction_is_possible"><code class="name flex">
<span>def <span class="ident">acceleration_direction_is_possible</span></span>(<span>self, movement_is_rightwards)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>whether the path acceleration's movement is not possible because of either the screen or a platform</dd>
</dl>
<p>| This is used for both the acceleration_path and deceleration_path. Figures out if the direction of acceleration
is possible (if it can't move right it can't accelerate right</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acceleration_direction_is_possible(self, movement_is_rightwards):
    &#34;&#34;&#34;
        Returns:
            boolean: whether the path acceleration&#39;s movement is not possible because of either the screen or a platform
            | This is used for both the acceleration_path and deceleration_path. Figures out if the direction of acceleration
            is possible (if it can&#39;t move right it can&#39;t accelerate right&#34;&#34;&#34;

    return self.can_move_right if movement_is_rightwards else self.can_move_left</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.alter_player_horizontal_movement"><code class="name flex">
<span>def <span class="ident">alter_player_horizontal_movement</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alters the player's horizontal movement so it stays within the screen and is not touching the platforms</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter_player_horizontal_movement(self):
    &#34;&#34;&#34;Alters the player&#39;s horizontal movement so it stays within the screen and is not touching the platforms&#34;&#34;&#34;

    player_is_beyond_screen_left = is_beyond_screen_left(self.left_edge)
    player_is_beyond_screen_right = is_beyond_screen_right(self.right_edge)

    self.alter_player_horizontal_movement_booleans(player_is_beyond_screen_left, player_is_beyond_screen_right)
    self.alter_player_left_edge_if_necessary(player_is_beyond_screen_left, player_is_beyond_screen_right)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.alter_player_horizontal_movement_booleans"><code class="name flex">
<span>def <span class="ident">alter_player_horizontal_movement_booleans</span></span>(<span>self, player_is_beyond_screen_left, player_is_beyond_screen_right)</span>
</code></dt>
<dd>
<div class="desc"><p>Alters the player's horizontal movement direction boolean attributes: 'can_move_left' and 'can_move_right'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter_player_horizontal_movement_booleans(self, player_is_beyond_screen_left, player_is_beyond_screen_right):
    &#34;&#34;&#34;Alters the player&#39;s horizontal movement direction boolean attributes: &#39;can_move_left&#39; and &#39;can_move_right&#39;&#34;&#34;&#34;

    is_decelerating_rightwards = not self.deceleration_path.has_finished() and self.get_deceleration_is_rightwards()
    is_decelerating_leftwards = not self.deceleration_path.has_finished() and not self.get_deceleration_is_rightwards()

    # Possible relating to everything but the deceleration
    leftwards_movement_is_possible = not self.right_collision_data[0] and not player_is_beyond_screen_left
    rightwards_movement_is_possible = not self.left_collision_data[0] and not player_is_beyond_screen_right

    self.can_move_left = leftwards_movement_is_possible and not is_decelerating_rightwards
    self.can_move_right = rightwards_movement_is_possible and not is_decelerating_leftwards</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.alter_player_left_edge_if_necessary"><code class="name flex">
<span>def <span class="ident">alter_player_left_edge_if_necessary</span></span>(<span>self, player_is_beyond_screen_left, player_is_beyond_screen_right)</span>
</code></dt>
<dd>
<div class="desc"><p>Alters the player's left edge if it is needed: the player has collided with the platform, or has gone beyond the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter_player_left_edge_if_necessary(self, player_is_beyond_screen_left, player_is_beyond_screen_right):
    &#34;&#34;&#34;Alters the player&#39;s left edge if it is needed: the player has collided with the platform, or has gone beyond the screen&#34;&#34;&#34;

    # Setting the player&#39;s x coordinate if the any of the above conditions were met (collided with platform or beyond screen)
    self.change_attribute_if(player_is_beyond_screen_left, self.set_left_edge, 0)
    self.change_attribute_if(player_is_beyond_screen_right, self.set_left_edge, SCREEN_LENGTH - self.length)

    if self.right_collision_data[0]:
        self.set_left_edge(self.right_collision_data[1].right_edge)

    if self.left_collision_data[0]:
        self.set_left_edge(self.left_collision_data[1].left_edge - self.length)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.alter_player_vertical_movement"><code class="name flex">
<span>def <span class="ident">alter_player_vertical_movement</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alters the player's vertical movement so it can't go through platforms</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter_player_vertical_movement(self):
    &#34;&#34;&#34;Alters the player&#39;s vertical movement so it can&#39;t go through platforms&#34;&#34;&#34;

    player_is_on_platform = self.top_collision_data[0]

    if player_is_on_platform:
        self.set_top_edge(self.top_collision_data[1].top_edge - self.height)

    self.set_is_on_platform(player_is_on_platform, self.top_collision_data[1])

    if self.bottom_collision_data[0]:
        self.run_bottom_edge_collision(self.bottom_collision_data[1].bottom_edge)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.cause_damage"><code class="name flex">
<span>def <span class="ident">cause_damage</span></span>(<span>self, amount)</span>
</code></dt>
<dd>
<div class="desc"><p>Damages the player by that amount and also starts the player's invincibility</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cause_damage(self, amount):
    &#34;&#34;&#34;Damages the player by that amount and also starts the player&#39;s invincibility&#34;&#34;&#34;

    if self.invincibility_event.has_finished():
        self.hit_points_left -= amount
        self.invincibility_event.start()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.change_attribute_if"><code class="name flex">
<span>def <span class="ident">change_attribute_if</span></span>(<span>self, condition, function, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the attribute to the value if 'condition()' is True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_attribute_if(self, condition, function, value):
    &#34;&#34;&#34;Changes the attribute to the value if &#39;condition()&#39; is True&#34;&#34;&#34;

    if condition:
        function(value)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.continue_acceleration_after_partial_deceleration"><code class="name flex">
<span>def <span class="ident">continue_acceleration_after_partial_deceleration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the time of the acceleration_path, so that it will pick up at the velocity where the deceleration ended at</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def continue_acceleration_after_partial_deceleration(self):
    &#34;&#34;&#34;Updates the time of the acceleration_path, so that it will pick up at the velocity where the deceleration ended at&#34;&#34;&#34;

    current_velocity = self.deceleration_path.get_velocity_using_time(self.deceleration_path.current_time)
    self.acceleration_path.start()

    # Figuring out the time to get to that velocity, so the player can continue to accelerate to the max velocity
    self.acceleration_path.current_time = sqrt(abs(current_velocity) / self.acceleration_path.acceleration)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.create_paths"><code class="name flex">
<span>def <span class="ident">create_paths</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates all the paths for the player: jumping_path, decelerating_path, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_paths(self):
    &#34;&#34;&#34;Creates all the paths for the player: jumping_path, decelerating_path, etc.&#34;&#34;&#34;

    self.jumping_piecewise_function = PiecewiseFunction([])
    self.falling_piecewise_function = PiecewiseFunction([])

    self.jumping_path = PiecewiseFollowablePath(self.jumping_piecewise_function, game_object=self, attribute_modifying=&#34;top_edge&#34;)

    self.set_running_acceleration_time(self.running_acceleration_time)
    self.set_running_deceleration_time(self.running_deceleration_time)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.decelerate_player"><code class="name flex">
<span>def <span class="ident">decelerate_player</span></span>(<span>self, is_moving_right)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the player decelerate by calling deceleration_path.start()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decelerate_player(self, is_moving_right):
    &#34;&#34;&#34;Makes the player decelerate by calling deceleration_path.start()&#34;&#34;&#34;

    self.deceleration_path.initial_distance = self.left_edge
    self.deceleration_path.initial_velocity = self.current_velocity if is_moving_right else -self.current_velocity

    # If the player is not at maximum velocity it shouldn&#39;t take as long to decelerate
    fraction_of_max_velocity = self.current_velocity / self.max_horizontal_velocity
    time_needed = self.running_deceleration_time * fraction_of_max_velocity

    # Gotten using math; Makes the player stop in the amount of time &#39;self.running_deceleration_time&#39;
    self.deceleration_path.acceleration = -self.deceleration_path.initial_velocity / time_needed

    self.deceleration_path.start()
    self.deceleration_path.max_time = time_needed</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_deceleration_is_rightwards"><code class="name flex">
<span>def <span class="ident">get_deceleration_is_rightwards</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>if the deceleration direction is rightwards</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_deceleration_is_rightwards(self):
    &#34;&#34;&#34;
        Returns:
            boolean: if the deceleration direction is rightwards&#34;&#34;&#34;

    # The deceleration must be going left to stop the player from moving right and vice versa
    return self.deceleration_path.acceleration &lt; 0</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_distance_to_reach_max_velocity"><code class="name flex">
<span>def <span class="ident">get_distance_to_reach_max_velocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>double</code></dt>
<dd>the distance needed for the player to reach max velocity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_distance_to_reach_max_velocity(self):
    &#34;&#34;&#34;
        Returns:
            double: the distance needed for the player to reach max velocity&#34;&#34;&#34;

    time_needed = self.max_horizontal_velocity / self.acceleration_path.acceleration
    return self.acceleration_path.get_distance(time_needed)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_horizontal_velocity"><code class="name flex">
<span>def <span class="ident">get_horizontal_velocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>double</code></dt>
<dd>the current velocity of the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_horizontal_velocity(self):
    &#34;&#34;&#34;
        Returns:
            double: the current velocity of the player&#34;&#34;&#34;

    # The velocity of the player is two-fold: either it has its usual velocity when it is not decelerating, or it has
    # The velocity from the deceleration. The deceleration_path does not affect the current_velocity because it was
    # Easier not to do that, so it does not do it that way
    deceleration_velocity = self.deceleration_path.get_velocity_using_time(self.deceleration_path.current_time)
    normal_velocity = self.current_velocity

    return normal_velocity if self.deceleration_path.has_finished() else deceleration_velocity</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_jumping_path_bounded_functions"><code class="name flex">
<span>def <span class="ident">get_jumping_path_bounded_functions</span></span>(<span>self, functions, delta_times)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list[BoundedFunction]</code></dt>
<dd>the piecewise function with the specified functions and delta times (adds a terminal</dd>
</dl>
<p>velocity function if the terminal velocity is reached). Assumes the last function is the one which should
have the velocity clamped at terminal velocity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_jumping_path_bounded_functions(self, functions, delta_times):
    &#34;&#34;&#34;
        Returns:
            list[BoundedFunction]: the piecewise function with the specified functions and delta times (adds a terminal
            velocity function if the terminal velocity is reached). Assumes the last function is the one which should
            have the velocity clamped at terminal velocity.
    &#34;&#34;&#34;

    # So the player&#39;s velocity is clamped at terminal velocity
    terminal_velocity_function = Function.get_new_function(lambda x: self.terminal_velocity)
    last_function = functions[len(functions) - 1]
    terminal_velocity_delta_time = self.get_terminal_velocity_delta_time(last_function.get_polynomial(),
                                                                         self.terminal_velocity)
    if terminal_velocity_delta_time is not None:
        functions.append(terminal_velocity_function)
        delta_times[len(delta_times) - 1] = terminal_velocity_delta_time
        delta_times.append(float(&#34;inf&#34;))

    return PiecewiseFunction.get_bounded_functions_with_delta_times(functions, delta_times, 0)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_max_time_to_top_edge"><code class="name flex">
<span>def <span class="ident">get_max_time_to_top_edge</span></span>(<span>self, start_top_edge, new_top_edge)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>double</code></dt>
<dd>the max amount of time for the player's bottom_edge to reach the new y coordinate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_time_to_top_edge(self, start_top_edge, new_top_edge):
    &#34;&#34;&#34;
        Returns:
             double: the max amount of time for the player&#39;s bottom_edge to reach the new y coordinate&#34;&#34;&#34;

    # TODO actually solve this
    return 1.2</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_terminal_velocity_delta_time"><code class="name flex">
<span>def <span class="ident">get_terminal_velocity_delta_time</span></span>(<span>self, function:<a title="game_qu.math.polynomial.Polynomial" href="../math/polynomial.html#game_qu.math.polynomial.Polynomial">Polynomial</a>, terminal_velocity)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>how long it takes for the player to go from falling to reaching terminal velocity (None if the terminal velocity is never reached)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_terminal_velocity_delta_time(self, function: Polynomial, terminal_velocity):
    &#34;&#34;&#34;
        Returns:
            float: how long it takes for the player to go from falling to reaching terminal velocity (None if the terminal velocity is never reached)
    &#34;&#34;&#34;

    times_when_terminal_velocity_is_reached = function.get_derivative().get_x_coordinates(terminal_velocity)

    # Only the positive time is wanted (don&#39;t care about other side of polynomial)
    for time in times_when_terminal_velocity_is_reached:
        if time &gt; 0:
            return time

    raise None</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_topmost_top_edge"><code class="name flex">
<span>def <span class="ident">get_topmost_top_edge</span></span>(<span>self, last_platform, accuracy, min_accuracy)</span>
</code></dt>
<dd>
<div class="desc"><p>Figures out the minimum top edge of the next platform (remember the closer to the top of the screen the lower the top edge)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>last_platform</code></strong> :&ensp;<code>Platform</code></dt>
<dd>the platform the player would be jumping from</dd>
<dt><strong><code>accuracy</code></strong> :&ensp;<code>double</code></dt>
<dd>how accurate the player has to be to clear this jump</dd>
<dt><strong><code>min_accuracy</code></strong> :&ensp;<code>double</code></dt>
<dd>the minimum accuracy possible</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>double</code></dt>
<dd>the max top edge that the next platform could be at that leaves the player 'margin_of_error'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_topmost_top_edge(self, last_platform, accuracy, min_accuracy):
    &#34;&#34;&#34;Figures out the minimum top edge of the next platform (remember the closer to the top of the screen the lower the top edge)

        Args:
            last_platform (Platform): the platform the player would be jumping from
            accuracy (double): how accurate the player has to be to clear this jump
            min_accuracy (double): the minimum accuracy possible

        Returns:
            double: the max top edge that the next platform could be at that leaves the player &#39;margin_of_error&#39;
    &#34;&#34;&#34;

    topmost_top_edge = last_platform.top_edge - (self.high_jump_height * accuracy) + self.height

    # The absolute max of a platform is the player&#39;s height because the player has to get its bottom_edge on the platform
    # Which would mean the player&#39;s top edge would be 0 also

    if topmost_top_edge &lt;= self.height:
        topmost_top_edge = self.height

    return topmost_top_edge</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_vertical_acceleration"><code class="name flex">
<span>def <span class="ident">get_vertical_acceleration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the acceleration in the vertical direction of the player (falling acceleration)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertical_acceleration(self):
    &#34;&#34;&#34;
        Returns:
            float: the acceleration in the vertical direction of the player (falling acceleration)
    &#34;&#34;&#34;

    return PhysicsFunction(self.high_jump_height, self.time_to_high_jump_vertex, 0).get_acceleration()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.get_vertical_velocity"><code class="name flex">
<span>def <span class="ident">get_vertical_velocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the velocity of the player at this moment in time</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertical_velocity(self):
    &#34;&#34;&#34;
        Returns:
            float: the velocity of the player at this moment in time
    &#34;&#34;&#34;

    derivative = self.jumping_path.get_piecewise_function().get_derivative()
    return derivative.get_y_coordinate(self.jumping_path.get_current_time())</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.horizontal_movement_has_stopped"><code class="name flex">
<span>def <span class="ident">horizontal_movement_has_stopped</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>if horizontal movement has stopped (player has released a movement key)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def horizontal_movement_has_stopped(self):
    &#34;&#34;&#34;
        Returns:
            boolean: if horizontal movement has stopped (player has released a movement key)&#34;&#34;&#34;

    return game_button_has_been_released(self.right_key) or game_button_has_been_released(self.left_key)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.jump"><code class="name flex">
<span>def <span class="ident">jump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the player jump</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jump(self):
    &#34;&#34;&#34;Makes the player jump&#34;&#34;&#34;

    self.jumping_path.start()
    self.set_jumping_path_to_default_jump()
    self.has_jumped = True

    if self.jump_key_held_in_time != -1:
        self.run_jump_type()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.player_movement_direction_is_same_as_deceleration"><code class="name flex">
<span>def <span class="ident">player_movement_direction_is_same_as_deceleration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>if the direction the player is moving is equal to the deceleration</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def player_movement_direction_is_same_as_deceleration(self):
    &#34;&#34;&#34;
        Returns:
            boolean: if the direction the player is moving is equal to the deceleration&#34;&#34;&#34;

    deceleration_direction_is_rightwards = self.deceleration_path.acceleration &lt; 0

    # Looking at both the leftwards and rightwards movement: movement and deceleration have both to be leftwards or rightwards
    rightwards_movement_is_same_as_deceleration = deceleration_direction_is_rightwards and game_button_is_pressed(self.right_key)
    leftwards_movement_is_same_as_deceleration = not deceleration_direction_is_rightwards and game_button_is_pressed(self.left_key)

    return leftwards_movement_is_same_as_deceleration or rightwards_movement_is_same_as_deceleration</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the player back to the start of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Resets the player back to the start of the game&#34;&#34;&#34;

    self.left_edge = self.base_left_edge
    self.top_edge = self.base_top_edge

    self.weapon.reset()
    self.run_respawning()  # Resetting from the game ending and respawning has a lot in similarity</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs all the code that is necessary for the player to work properly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;Runs all the code that is necessary for the player to work properly&#34;&#34;&#34;

    self.invincibility_event.run(self.invincibility_event.current_time &gt; self.invincibility_event.time_needed, False)
    self.run_horizontal_movement()
    self.run_vertical_movement()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_acceleration"><code class="name flex">
<span>def <span class="ident">run_acceleration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs all the code for acceleration (so the player comes to the max velocity)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_acceleration(self):
    &#34;&#34;&#34;Runs all the code for acceleration (so the player comes to the max velocity)&#34;&#34;&#34;

    if self.player_movement_direction_is_same_as_deceleration():
        self.continue_acceleration_after_partial_deceleration()

    if self.deceleration_path.has_finished():
        GameMovement.run_acceleration(self, game_button_is_pressed(self.left_key) or game_button_is_pressed(self.right_key), self.acceleration_path, self.max_horizontal_velocity)

    if not self.acceleration_direction_is_possible(self.acceleration_path.acceleration &gt; 0):
        self.acceleration_path.reset()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_bottom_edge_collision"><code class="name flex">
<span>def <span class="ident">run_bottom_edge_collision</span></span>(<span>self, top_edge)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs what should happen after a bottom collision (the player should rebound off of it)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_bottom_edge_collision(self, top_edge):
    &#34;&#34;&#34;Runs what should happen after a bottom collision (the player should rebound off of it)&#34;&#34;&#34;

    velocity = self.get_vertical_velocity()
    falling_function = PhysicsFunction(self.high_jump_height, self.time_to_high_jump_vertex, self.top_edge)
    falling_function.set_initial_velocity(velocity)
    functions = self.get_jumping_path_bounded_functions([falling_function],
                                                        [self.time_from_high_jump_vertex_to_ground])

    self.falling_piecewise_function.set_functions(functions)
    self.set_jumping_path_to_falling_path()

    self.jumping_path.reset()
    self.top_edge = top_edge</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_collisions"><code class="name flex">
<span>def <span class="ident">run_collisions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs what should happen based on what got stored in the collision data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_collisions(self):
    &#34;&#34;&#34;Runs what should happen based on what got stored in the collision data&#34;&#34;&#34;

    # The player should only act upon the collision data if there was stuff in the History Keeper because if there wasn&#39;t
    # Then the game is automatically going to say it was not a collision (top, left, right, bottom)
    if HistoryKeeper.get_last(self.name) is not None:
        self.alter_player_horizontal_movement()
        self.alter_player_vertical_movement()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_deceleration"><code class="name flex">
<span>def <span class="ident">run_deceleration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs all the code for decelerating (so the player comes to a stop slowly)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_deceleration(self):
    &#34;&#34;&#34;Runs all the code for decelerating (so the player comes to a stop slowly)&#34;&#34;&#34;

    deceleration_direction_is_possible = self.acceleration_direction_is_possible(self.get_deceleration_is_rightwards())

    # Meaning no outside force has stopped the deceleration like platforms or screen limits
    deceleration_has_manually_stopped = self.deceleration_path.has_finished() or self.player_movement_direction_is_same_as_deceleration()
    can_decelerate = deceleration_direction_is_possible and not deceleration_has_manually_stopped

    if can_decelerate:
        self.deceleration_path.run(False, False, is_changing_coordinates=False)
        self.left_edge += self.deceleration_path.get_total_displacement()

    else:
        self.deceleration_path.reset()

    if self.horizontal_movement_has_stopped():
        self.decelerate_player(game_button_has_been_released(self.right_key))</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_horizontal_movement"><code class="name flex">
<span>def <span class="ident">run_horizontal_movement</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs all the code for horizontal movement: acceleration, deceleration, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_horizontal_movement(self):
    &#34;&#34;&#34;Runs all the code for horizontal movement: acceleration, deceleration, etc.&#34;&#34;&#34;

    self.is_facing_right = True if game_button_is_pressed(self.right_key) else self.is_facing_right
    self.is_facing_right = False if game_button_is_pressed(self.left_key) else self.is_facing_right

    self.run_deceleration()
    self.run_acceleration()

    GameMovement.player_horizontal_movement(self, self.current_velocity, self.left_key, self.right_key)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_inanimate_object_collision"><code class="name flex">
<span>def <span class="ident">run_inanimate_object_collision</span></span>(<span>self, inanimate_object, index_of_sub_component)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs what should happen when the player collides with an inanimate object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_inanimate_object_collision(self, inanimate_object, index_of_sub_component):
    &#34;&#34;&#34;Runs what should happen when the player collides with an inanimate object&#34;&#34;&#34;

    if index_of_sub_component == self.index_of_user:
        self.update_platform_collision_data(inanimate_object)

    if index_of_sub_component != self.index_of_user:
        self.weapon.run_inanimate_object_collision(inanimate_object, index_of_sub_component - self.weapon_index_offset)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_jump_type"><code class="name flex">
<span>def <span class="ident">run_jump_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a different jump type (small, medium, or large) depending on how long the key was held in</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_jump_type(self):
    &#34;&#34;&#34;Runs a different jump type (small, medium, or large) depending on how long the key was held in&#34;&#34;&#34;

    # In this case the y coordinate is the function that should be called
    self.time_to_jump_type.get_y_coordinate(self.jump_key_held_in_time)()
    self.jump_key_held_in_time = -1</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_respawning"><code class="name flex">
<span>def <span class="ident">run_respawning</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the player respawn (resets most things)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_respawning(self):
    &#34;&#34;&#34;Makes the player respawn (resets most things)&#34;&#34;&#34;

    self.is_on_platform = True
    self.hit_points_left = self.total_hit_points
    self.invincibility_event.reset()

    # Resetting the direction the player can move
    self.can_move_left, self.can_move_right, self.can_move_down = False, False, False

    for path_or_event in self.all_paths_and_events:
        path_or_event.reset()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.run_vertical_movement"><code class="name flex">
<span>def <span class="ident">run_vertical_movement</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs all the vertical movement (mostly jumping)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_vertical_movement(self):
    &#34;&#34;&#34;Runs all the vertical movement (mostly jumping)&#34;&#34;&#34;

    if game_button_is_clicked(self.jump_key):
        if self.is_on_platform:
            self.jump()

        if self.coyote_timed_event.is_running():
            self.jump()
            self.coyote_timed_event.reset()

    if game_button_has_been_released(self.jump_key):
        self.jump_key_held_in_time = get_time_of_game_button_being_held_in(self.jump_key)

        if self.has_jumped:
            self.run_jump_type(self.jump_key_held_in_time)

    if self.top_edge &lt;= 0:
        self.run_bottom_edge_collision(0)

    self.jumping_path.run(is_changing_attribute=True)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_apex_horizontal_velocity_multiplier"><code class="name flex">
<span>def <span class="ident">set_apex_horizontal_velocity_multiplier</span></span>(<span>self, apex_horizontal_velocity_multiplier)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_apex_horizontal_velocity_multiplier(self, apex_horizontal_velocity_multiplier):
    self.apex_horizontal_velocity_multiplier = apex_horizontal_velocity_multiplier</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_apex_jump_time"><code class="name flex">
<span>def <span class="ident">set_apex_jump_time</span></span>(<span>self, apex_jump_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_apex_jump_time(self, apex_jump_time):
    self.apex_jump_time = apex_jump_time</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_base_coordinates"><code class="name flex">
<span>def <span class="ident">set_base_coordinates</span></span>(<span>self, base_left_edge, base_top_edge)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the base coordinates of the player</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base_coordinates(self, base_left_edge, base_top_edge):
    &#34;&#34;&#34;Sets the base coordinates of the player&#34;&#34;&#34;

    self.base_left_edge = base_left_edge
    self.base_top_edge = base_top_edge</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_base_left_edge"><code class="name flex">
<span>def <span class="ident">set_base_left_edge</span></span>(<span>self, base_left_edge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base_left_edge(self, base_left_edge):
    self.base_left_edge = base_left_edge</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_base_top_edge"><code class="name flex">
<span>def <span class="ident">set_base_top_edge</span></span>(<span>self, base_top_edge)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base_top_edge(self, base_top_edge):
    self.base_top_edge = base_top_edge</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_coyote_time"><code class="name flex">
<span>def <span class="ident">set_coyote_time</span></span>(<span>self, coyote_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_coyote_time(self, coyote_time):
    self.coyote_time = coyote_time</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_high_jump_height"><code class="name flex">
<span>def <span class="ident">set_high_jump_height</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_high_jump_height(self, variable):
    self.high_jump_height = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_high_jump_time_held_in"><code class="name flex">
<span>def <span class="ident">set_high_jump_time_held_in</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_high_jump_time_held_in(self, variable):
    self.high_jump_time_held_in = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_invincibility_total_time"><code class="name flex">
<span>def <span class="ident">set_invincibility_total_time</span></span>(<span>self, invincibility_total_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_invincibility_total_time(self, invincibility_total_time):
    self.invincibility_total_time = invincibility_total_time</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_is_on_platform"><code class="name flex">
<span>def <span class="ident">set_is_on_platform</span></span>(<span>self, is_on_platform, platform_is_on)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the player's 'is_on_platform' attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_on_platform(self, is_on_platform, platform_is_on):
    &#34;&#34;&#34;Sets the player&#39;s &#39;is_on_platform&#39; attribute&#34;&#34;&#34;

    if not self.is_on_platform and is_on_platform:
        self.jumping_path.reset()

    if self.is_on_platform and not is_on_platform and not self.has_jumped:
        self.set_jumping_path_to_falling_path()

    if self.jump_buffer_timed_event.is_running():
        self.jump()
        self.jump_buffer_timed_event.reset()

    self.last_platform_was_on = platform_is_on if is_on_platform else self.last_platform_was_on
    self.platform_is_on = platform_is_on if is_on_platform else None
    self.is_on_platform = is_on_platform</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_jump_buffer_time"><code class="name flex">
<span>def <span class="ident">set_jump_buffer_time</span></span>(<span>self, jump_buffer_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_jump_buffer_time(self, jump_buffer_time):
    self.jump_buffer_time = jump_buffer_time</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_jumping_path_to_default_jump"><code class="name flex">
<span>def <span class="ident">set_jumping_path_to_default_jump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the variable 'jumping_path' to a path that defines the player's jump (falling and jumping have different
gravities to make the game feel better)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_jumping_path_to_default_jump(self):
    &#34;&#34;&#34; Sets the variable &#39;jumping_path&#39; to a path that defines the player&#39;s jump (falling and jumping have different
        gravities to make the game feel better)&#34;&#34;&#34;

    self.update_jumping_path()
    self.jumping_path.set_piecewise_function(self.jumping_piecewise_function)
    self.jumping_path.restart()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_jumping_path_to_falling_path"><code class="name flex">
<span>def <span class="ident">set_jumping_path_to_falling_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the variable 'jumping_path' to a path that defines the player's fall (falling and jumping have different
gravities to make the game feel better)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_jumping_path_to_falling_path(self):
    &#34;&#34;&#34; Sets the variable &#39;jumping_path&#39; to a path that defines the player&#39;s fall (falling and jumping have different
        gravities to make the game feel better)&#34;&#34;&#34;

    self.update_falling_path()
    self.jumping_path.set_piecewise_function(self.falling_piecewise_function)
    self.jumping_path.restart()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_jumping_path_with_apex"><code class="name flex">
<span>def <span class="ident">set_jumping_path_with_apex</span></span>(<span>self, time_to_jump_vertex, jump_height, time_from_vertex_to_ground)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the jumping path of the player, so it has the jump height and time to vertex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_jumping_path_with_apex(self, time_to_jump_vertex, jump_height, time_from_vertex_to_ground):
    &#34;&#34;&#34;Sets the jumping path of the player, so it has the jump height and time to vertex&#34;&#34;&#34;

    # Finding the jumping path as defined by its 4 functions (upwards, apex, downwards, terminal velocity)
    # Finding the initial variables we need for the calculations below
    jumping_function: PhysicsFunction = self.jumping_piecewise_function.get_functions()[0].get_function()
    time_spent_in_air = self.jumping_path.get_current_time()
    height_jumped = jumping_function.get_displacement(0, time_spent_in_air)
    jump_height_left = jump_height - height_jumped
    time_left = time_to_jump_vertex - time_spent_in_air

    # Calculating the apex variables
    apex_time_left = max_value(self.minimum_jump_deceleration_time, time_left)
    vertex = self.top_edge - jump_height_left
    initial_velocity = self.get_vertical_velocity()

    # Using variables found above to get the functions
    upwards_function = PhysicsFunction()
    upwards_function.set_variables(initial_velocity=initial_velocity, initial_distance=self.top_edge)
    upwards_function.set_acceleration_with_velocity(apex_time_left, -initial_velocity)

    apex_function = Function.get_new_function(lambda x: vertex)  # So the player stays at the vertex
    downwards_function = PhysicsFunction(self.top_edge, time_from_vertex_to_ground, vertex)

    functions = [vertex, upwards_function, apex_function, downwards_function]
    delta_times = [time_to_jump_vertex, self.apex_jump_time, time_from_vertex_to_ground]

    bounded_functions = self.get_jumping_path_bounded_functions(functions, delta_times)
    self.jumping_piecewise_function.set_functions(bounded_functions)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_left_edge"><code class="name flex">
<span>def <span class="ident">set_left_edge</span></span>(<span>self, left_edge)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the left edge of the player equal to the value provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_left_edge(self, left_edge):
    &#34;&#34;&#34;Sets the left edge of the player equal to the value provided&#34;&#34;&#34;

    self.left_edge = left_edge</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_max_horizontal_velocity"><code class="name flex">
<span>def <span class="ident">set_max_horizontal_velocity</span></span>(<span>self, max_horizontal_velocity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_max_horizontal_velocity(self, max_horizontal_velocity):
    self.max_horizontal_velocity = max_horizontal_velocity</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_medium_jump_height"><code class="name flex">
<span>def <span class="ident">set_medium_jump_height</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_medium_jump_height(self, variable):
    self.medium_jump_height = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_medium_jump_time_held_in"><code class="name flex">
<span>def <span class="ident">set_medium_jump_time_held_in</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_medium_jump_time_held_in(self, variable):
    self.medium_jump_time_held_in = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_object_type"><code class="name flex">
<span>def <span class="ident">set_object_type</span></span>(<span>self, object_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_object_type(self, object_type):
    self.object_type = object_type</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_running_acceleration_time"><code class="name flex">
<span>def <span class="ident">set_running_acceleration_time</span></span>(<span>self, running_acceleration_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_running_acceleration_time(self, running_acceleration_time):
    self.running_acceleration_time = running_acceleration_time
    self.acceleration_path = PhysicsPath()
    self.acceleration_path.set_acceleration_with_velocity(self.running_acceleration_time, self.max_horizontal_velocity)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_running_deceleration_time"><code class="name flex">
<span>def <span class="ident">set_running_deceleration_time</span></span>(<span>self, running_deceleration_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_running_deceleration_time(self, running_deceleration_time):
    self.running_deceleration_time = running_deceleration_time

    self.deceleration_path = PhysicsPath(game_object=self, attribute_modifying=&#34;left_edge&#34;, max_time=self.running_deceleration_time)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_small_jump_height"><code class="name flex">
<span>def <span class="ident">set_small_jump_height</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_small_jump_height(self, variable):
    self.small_jump_height = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_small_jump_time_held_in"><code class="name flex">
<span>def <span class="ident">set_small_jump_time_held_in</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_small_jump_time_held_in(self, variable):
    self.small_jump_time_held_in = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_terminal_velocity"><code class="name flex">
<span>def <span class="ident">set_terminal_velocity</span></span>(<span>self, terminal_velocity)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_terminal_velocity(self, terminal_velocity):
    self.terminal_velocity = terminal_velocity</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_time_from_high_jump_vertex_to_ground"><code class="name flex">
<span>def <span class="ident">set_time_from_high_jump_vertex_to_ground</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_from_high_jump_vertex_to_ground(self, variable):
    self.time_from_high_jump_vertex_to_ground = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_time_from_medium_jump_vertex_to_ground"><code class="name flex">
<span>def <span class="ident">set_time_from_medium_jump_vertex_to_ground</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_from_medium_jump_vertex_to_ground(self, variable):
    self.time_from_medium_jump_vertex_to_ground = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_time_from_small_jump_vertex_to_ground"><code class="name flex">
<span>def <span class="ident">set_time_from_small_jump_vertex_to_ground</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_from_small_jump_vertex_to_ground(self, variable):
    self.time_from_small_jump_vertex_to_ground = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_time_to_high_jump_vertex"><code class="name flex">
<span>def <span class="ident">set_time_to_high_jump_vertex</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_to_high_jump_vertex(self, variable):
    self.time_to_high_jump_vertex = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_time_to_medium_jump_vertex"><code class="name flex">
<span>def <span class="ident">set_time_to_medium_jump_vertex</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_to_medium_jump_vertex(self, variable):
    self.time_to_medium_jump_vertex = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_time_to_small_jump_vertex"><code class="name flex">
<span>def <span class="ident">set_time_to_small_jump_vertex</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_to_small_jump_vertex(self, variable):
    self.time_to_small_jump_vertex = variable
    self.update_jump_types()</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.set_total_hit_points"><code class="name flex">
<span>def <span class="ident">set_total_hit_points</span></span>(<span>self, total_hit_points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_total_hit_points(self, total_hit_points):
    self.total_hit_points = total_hit_points</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.update_falling_path"><code class="name flex">
<span>def <span class="ident">update_falling_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the path of the player, so they fall</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_falling_path(self):
    &#34;&#34;&#34;Updates the path of the player, so they fall&#34;&#34;&#34;

    # Finding the normal falling path as defined by its 2 functions (falling, terminal velocity)
    falling_function = PhysicsFunction(self.top_edge + self.high_jump_height, self.time_to_high_jump_vertex, self.top_edge)
    bounded_functions = self.get_jumping_path_bounded_functions([falling_function], [self.time_to_high_jump_vertex])
    self.falling_piecewise_function.set_functions(bounded_functions)</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.update_jump_types"><code class="name flex">
<span>def <span class="ident">update_jump_types</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the variables of the player, so the jump heights work</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_jump_types(self):
    &#34;&#34;&#34;Updates the variables of the player, so the jump heights work&#34;&#34;&#34;

    # The x coordinate is the time the jump key is held in and the y coordinate is the index of the function
    self.time_to_jump_type = LinearInterpolation(Point(0, 0),
                                                 [Point(self.small_jump_time_held_in, 0),
                                                  Point(self.medium_jump_time_held_in, 1),
                                                  Point(self.high_jump_time_held_in, 2),
                                                  Point(float(&#34;inf&#34;), 2)])</code></pre>
</details>
</dd>
<dt id="game_qu.platformer.player.Player.update_jumping_path"><code class="name flex">
<span>def <span class="ident">update_jumping_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the path of the player, so they jump</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_jumping_path(self):
    &#34;&#34;&#34;Updates the path of the player, so they jump&#34;&#34;&#34;

    self._set_jumping_path_to_high_jump()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="game_qu.platformer.weapon_user.WeaponUser" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser">WeaponUser</a></b></code>:
<ul class="hlist">
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.bottom_edge" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions.bottom_edge">bottom_edge</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.get_all_components" href="game_object.html#game_qu.platformer.game_object.GameObject.get_all_components">get_all_components</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.get_collidable_components" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.get_collidable_components">get_collidable_components</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.get_collision_data" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.get_collision_data">get_collision_data</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.get_components" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.get_components">get_components</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.get_scaled_dimensions" href="../gui_components/component.html#game_qu.gui_components.component.Component.get_scaled_dimensions">get_scaled_dimensions</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.got_clicked" href="../gui_components/component.html#game_qu.gui_components.component.Component.got_clicked">got_clicked</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.horizontal_midpoint" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions.horizontal_midpoint">horizontal_midpoint</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.mouse_enter_function" href="../gui_components/component.html#game_qu.gui_components.component.Component.mouse_enter_function">mouse_enter_function</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.mouse_exit_function" href="../gui_components/component.html#game_qu.gui_components.component.Component.mouse_exit_function">mouse_exit_function</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.number_set_dimensions" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions.number_set_dimensions">number_set_dimensions</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.percentage_set_dimensions" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions.percentage_set_dimensions">percentage_set_dimensions</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.render" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.render">render</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.reset_collision_data" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.reset_collision_data">reset_collision_data</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.right_edge" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions.right_edge">right_edge</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.run_enemy_collision" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.run_enemy_collision">run_enemy_collision</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.run_upon_activation" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.run_upon_activation">run_upon_activation</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.set_color" href="../gui_components/component.html#game_qu.gui_components.component.Component.set_color">set_color</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.set_dimensions_within_component" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions.set_dimensions_within_component">set_dimensions_within_component</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.set_mouse_enter_function" href="../gui_components/component.html#game_qu.gui_components.component.Component.set_mouse_enter_function">set_mouse_enter_function</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.set_mouse_exit_function" href="../gui_components/component.html#game_qu.gui_components.component.Component.set_mouse_exit_function">set_mouse_exit_function</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.set_mouse_functions" href="../gui_components/component.html#game_qu.gui_components.component.Component.set_mouse_functions">set_mouse_functions</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.update_collision_data" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.update_collision_data">update_collision_data</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.update_for_side_scrolling" href="game_object.html#game_qu.platformer.game_object.GameObject.update_for_side_scrolling">update_for_side_scrolling</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.update_platform_collision_data" href="weapon_user.html#game_qu.platformer.weapon_user.WeaponUser.update_platform_collision_data">update_platform_collision_data</a></code></li>
<li><code><a title="game_qu.platformer.weapon_user.WeaponUser.vertical_midpoint" href="../gui_components/dimensions.html#game_qu.gui_components.dimensions.Dimensions.vertical_midpoint">vertical_midpoint</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="game_qu.platformer" href="index.html">game_qu.platformer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="game_qu.platformer.player.Player" href="#game_qu.platformer.player.Player">Player</a></code></h4>
<ul class="">
<li><code><a title="game_qu.platformer.player.Player.acceleration_direction_is_possible" href="#game_qu.platformer.player.Player.acceleration_direction_is_possible">acceleration_direction_is_possible</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.acceleration_path" href="#game_qu.platformer.player.Player.acceleration_path">acceleration_path</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.all_paths_and_events" href="#game_qu.platformer.player.Player.all_paths_and_events">all_paths_and_events</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.alter_player_horizontal_movement" href="#game_qu.platformer.player.Player.alter_player_horizontal_movement">alter_player_horizontal_movement</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.alter_player_horizontal_movement_booleans" href="#game_qu.platformer.player.Player.alter_player_horizontal_movement_booleans">alter_player_horizontal_movement_booleans</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.alter_player_left_edge_if_necessary" href="#game_qu.platformer.player.Player.alter_player_left_edge_if_necessary">alter_player_left_edge_if_necessary</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.alter_player_vertical_movement" href="#game_qu.platformer.player.Player.alter_player_vertical_movement">alter_player_vertical_movement</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.apex_horizontal_velocity_multiplier" href="#game_qu.platformer.player.Player.apex_horizontal_velocity_multiplier">apex_horizontal_velocity_multiplier</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.apex_jump_time" href="#game_qu.platformer.player.Player.apex_jump_time">apex_jump_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.attack_key" href="#game_qu.platformer.player.Player.attack_key">attack_key</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.base_left_edge" href="#game_qu.platformer.player.Player.base_left_edge">base_left_edge</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.base_top_edge" href="#game_qu.platformer.player.Player.base_top_edge">base_top_edge</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.can_move_down" href="#game_qu.platformer.player.Player.can_move_down">can_move_down</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.can_move_left" href="#game_qu.platformer.player.Player.can_move_left">can_move_left</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.can_move_right" href="#game_qu.platformer.player.Player.can_move_right">can_move_right</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.cause_damage" href="#game_qu.platformer.player.Player.cause_damage">cause_damage</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.change_attribute_if" href="#game_qu.platformer.player.Player.change_attribute_if">change_attribute_if</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.continue_acceleration_after_partial_deceleration" href="#game_qu.platformer.player.Player.continue_acceleration_after_partial_deceleration">continue_acceleration_after_partial_deceleration</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.coyote_time" href="#game_qu.platformer.player.Player.coyote_time">coyote_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.coyote_timed_event" href="#game_qu.platformer.player.Player.coyote_timed_event">coyote_timed_event</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.create_paths" href="#game_qu.platformer.player.Player.create_paths">create_paths</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.current_velocity" href="#game_qu.platformer.player.Player.current_velocity">current_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.decelerate_player" href="#game_qu.platformer.player.Player.decelerate_player">decelerate_player</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.deceleration_path" href="#game_qu.platformer.player.Player.deceleration_path">deceleration_path</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.down_key" href="#game_qu.platformer.player.Player.down_key">down_key</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.falling_piecewise_function" href="#game_qu.platformer.player.Player.falling_piecewise_function">falling_piecewise_function</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_deceleration_is_rightwards" href="#game_qu.platformer.player.Player.get_deceleration_is_rightwards">get_deceleration_is_rightwards</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_distance_to_reach_max_velocity" href="#game_qu.platformer.player.Player.get_distance_to_reach_max_velocity">get_distance_to_reach_max_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_horizontal_velocity" href="#game_qu.platformer.player.Player.get_horizontal_velocity">get_horizontal_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_jumping_path_bounded_functions" href="#game_qu.platformer.player.Player.get_jumping_path_bounded_functions">get_jumping_path_bounded_functions</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_max_time_to_top_edge" href="#game_qu.platformer.player.Player.get_max_time_to_top_edge">get_max_time_to_top_edge</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_terminal_velocity_delta_time" href="#game_qu.platformer.player.Player.get_terminal_velocity_delta_time">get_terminal_velocity_delta_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_topmost_top_edge" href="#game_qu.platformer.player.Player.get_topmost_top_edge">get_topmost_top_edge</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_vertical_acceleration" href="#game_qu.platformer.player.Player.get_vertical_acceleration">get_vertical_acceleration</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.get_vertical_velocity" href="#game_qu.platformer.player.Player.get_vertical_velocity">get_vertical_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.has_jumped" href="#game_qu.platformer.player.Player.has_jumped">has_jumped</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.height" href="#game_qu.platformer.player.Player.height">height</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.high_jump_height" href="#game_qu.platformer.player.Player.high_jump_height">high_jump_height</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.high_jump_time_held_in" href="#game_qu.platformer.player.Player.high_jump_time_held_in">high_jump_time_held_in</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.hit_points_left" href="#game_qu.platformer.player.Player.hit_points_left">hit_points_left</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.horizontal_movement_has_stopped" href="#game_qu.platformer.player.Player.horizontal_movement_has_stopped">horizontal_movement_has_stopped</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.initial_upwards_velocity" href="#game_qu.platformer.player.Player.initial_upwards_velocity">initial_upwards_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.invincibility_event" href="#game_qu.platformer.player.Player.invincibility_event">invincibility_event</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.invincibility_total_time" href="#game_qu.platformer.player.Player.invincibility_total_time">invincibility_total_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.is_facing_right" href="#game_qu.platformer.player.Player.is_facing_right">is_facing_right</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.is_on_platform" href="#game_qu.platformer.player.Player.is_on_platform">is_on_platform</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.is_runnable" href="#game_qu.platformer.player.Player.is_runnable">is_runnable</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.jump" href="#game_qu.platformer.player.Player.jump">jump</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.jump_buffer_time" href="#game_qu.platformer.player.Player.jump_buffer_time">jump_buffer_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.jump_buffer_timed_event" href="#game_qu.platformer.player.Player.jump_buffer_timed_event">jump_buffer_timed_event</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.jump_key" href="#game_qu.platformer.player.Player.jump_key">jump_key</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.jump_key_held_in_time" href="#game_qu.platformer.player.Player.jump_key_held_in_time">jump_key_held_in_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.jumping_path" href="#game_qu.platformer.player.Player.jumping_path">jumping_path</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.jumping_piecewise_function" href="#game_qu.platformer.player.Player.jumping_piecewise_function">jumping_piecewise_function</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.last_platform_was_on" href="#game_qu.platformer.player.Player.last_platform_was_on">last_platform_was_on</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.left_key" href="#game_qu.platformer.player.Player.left_key">left_key</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.length" href="#game_qu.platformer.player.Player.length">length</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.max_horizontal_velocity" href="#game_qu.platformer.player.Player.max_horizontal_velocity">max_horizontal_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.medium_jump_height" href="#game_qu.platformer.player.Player.medium_jump_height">medium_jump_height</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.medium_jump_time_held_in" href="#game_qu.platformer.player.Player.medium_jump_time_held_in">medium_jump_time_held_in</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.minimum_jump_deceleration_time" href="#game_qu.platformer.player.Player.minimum_jump_deceleration_time">minimum_jump_deceleration_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.object_type" href="#game_qu.platformer.player.Player.object_type">object_type</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.platform_is_on" href="#game_qu.platformer.player.Player.platform_is_on">platform_is_on</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.player_movement_direction_is_same_as_deceleration" href="#game_qu.platformer.player.Player.player_movement_direction_is_same_as_deceleration">player_movement_direction_is_same_as_deceleration</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.reset" href="#game_qu.platformer.player.Player.reset">reset</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.right_key" href="#game_qu.platformer.player.Player.right_key">right_key</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run" href="#game_qu.platformer.player.Player.run">run</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_acceleration" href="#game_qu.platformer.player.Player.run_acceleration">run_acceleration</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_bottom_edge_collision" href="#game_qu.platformer.player.Player.run_bottom_edge_collision">run_bottom_edge_collision</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_collisions" href="#game_qu.platformer.player.Player.run_collisions">run_collisions</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_deceleration" href="#game_qu.platformer.player.Player.run_deceleration">run_deceleration</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_horizontal_movement" href="#game_qu.platformer.player.Player.run_horizontal_movement">run_horizontal_movement</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_inanimate_object_collision" href="#game_qu.platformer.player.Player.run_inanimate_object_collision">run_inanimate_object_collision</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_jump_type" href="#game_qu.platformer.player.Player.run_jump_type">run_jump_type</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_respawning" href="#game_qu.platformer.player.Player.run_respawning">run_respawning</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.run_vertical_movement" href="#game_qu.platformer.player.Player.run_vertical_movement">run_vertical_movement</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.running_acceleration_time" href="#game_qu.platformer.player.Player.running_acceleration_time">running_acceleration_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.running_deceleration_time" href="#game_qu.platformer.player.Player.running_deceleration_time">running_deceleration_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_apex_horizontal_velocity_multiplier" href="#game_qu.platformer.player.Player.set_apex_horizontal_velocity_multiplier">set_apex_horizontal_velocity_multiplier</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_apex_jump_time" href="#game_qu.platformer.player.Player.set_apex_jump_time">set_apex_jump_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_base_coordinates" href="#game_qu.platformer.player.Player.set_base_coordinates">set_base_coordinates</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_base_left_edge" href="#game_qu.platformer.player.Player.set_base_left_edge">set_base_left_edge</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_base_top_edge" href="#game_qu.platformer.player.Player.set_base_top_edge">set_base_top_edge</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_coyote_time" href="#game_qu.platformer.player.Player.set_coyote_time">set_coyote_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_high_jump_height" href="#game_qu.platformer.player.Player.set_high_jump_height">set_high_jump_height</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_high_jump_time_held_in" href="#game_qu.platformer.player.Player.set_high_jump_time_held_in">set_high_jump_time_held_in</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_invincibility_total_time" href="#game_qu.platformer.player.Player.set_invincibility_total_time">set_invincibility_total_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_is_on_platform" href="#game_qu.platformer.player.Player.set_is_on_platform">set_is_on_platform</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_jump_buffer_time" href="#game_qu.platformer.player.Player.set_jump_buffer_time">set_jump_buffer_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_jumping_path_to_default_jump" href="#game_qu.platformer.player.Player.set_jumping_path_to_default_jump">set_jumping_path_to_default_jump</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_jumping_path_to_falling_path" href="#game_qu.platformer.player.Player.set_jumping_path_to_falling_path">set_jumping_path_to_falling_path</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_jumping_path_with_apex" href="#game_qu.platformer.player.Player.set_jumping_path_with_apex">set_jumping_path_with_apex</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_left_edge" href="#game_qu.platformer.player.Player.set_left_edge">set_left_edge</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_max_horizontal_velocity" href="#game_qu.platformer.player.Player.set_max_horizontal_velocity">set_max_horizontal_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_medium_jump_height" href="#game_qu.platformer.player.Player.set_medium_jump_height">set_medium_jump_height</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_medium_jump_time_held_in" href="#game_qu.platformer.player.Player.set_medium_jump_time_held_in">set_medium_jump_time_held_in</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_object_type" href="#game_qu.platformer.player.Player.set_object_type">set_object_type</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_running_acceleration_time" href="#game_qu.platformer.player.Player.set_running_acceleration_time">set_running_acceleration_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_running_deceleration_time" href="#game_qu.platformer.player.Player.set_running_deceleration_time">set_running_deceleration_time</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_small_jump_height" href="#game_qu.platformer.player.Player.set_small_jump_height">set_small_jump_height</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_small_jump_time_held_in" href="#game_qu.platformer.player.Player.set_small_jump_time_held_in">set_small_jump_time_held_in</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_terminal_velocity" href="#game_qu.platformer.player.Player.set_terminal_velocity">set_terminal_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_time_from_high_jump_vertex_to_ground" href="#game_qu.platformer.player.Player.set_time_from_high_jump_vertex_to_ground">set_time_from_high_jump_vertex_to_ground</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_time_from_medium_jump_vertex_to_ground" href="#game_qu.platformer.player.Player.set_time_from_medium_jump_vertex_to_ground">set_time_from_medium_jump_vertex_to_ground</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_time_from_small_jump_vertex_to_ground" href="#game_qu.platformer.player.Player.set_time_from_small_jump_vertex_to_ground">set_time_from_small_jump_vertex_to_ground</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_time_to_high_jump_vertex" href="#game_qu.platformer.player.Player.set_time_to_high_jump_vertex">set_time_to_high_jump_vertex</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_time_to_medium_jump_vertex" href="#game_qu.platformer.player.Player.set_time_to_medium_jump_vertex">set_time_to_medium_jump_vertex</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_time_to_small_jump_vertex" href="#game_qu.platformer.player.Player.set_time_to_small_jump_vertex">set_time_to_small_jump_vertex</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.set_total_hit_points" href="#game_qu.platformer.player.Player.set_total_hit_points">set_total_hit_points</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.small_jump_height" href="#game_qu.platformer.player.Player.small_jump_height">small_jump_height</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.small_jump_time_held_in" href="#game_qu.platformer.player.Player.small_jump_time_held_in">small_jump_time_held_in</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.terminal_velocity" href="#game_qu.platformer.player.Player.terminal_velocity">terminal_velocity</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.time_from_high_jump_vertex_to_ground" href="#game_qu.platformer.player.Player.time_from_high_jump_vertex_to_ground">time_from_high_jump_vertex_to_ground</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.time_from_medium_jump_vertex_to_ground" href="#game_qu.platformer.player.Player.time_from_medium_jump_vertex_to_ground">time_from_medium_jump_vertex_to_ground</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.time_from_small_jump_vertex_to_ground" href="#game_qu.platformer.player.Player.time_from_small_jump_vertex_to_ground">time_from_small_jump_vertex_to_ground</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.time_to_high_jump_vertex" href="#game_qu.platformer.player.Player.time_to_high_jump_vertex">time_to_high_jump_vertex</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.time_to_jump_type" href="#game_qu.platformer.player.Player.time_to_jump_type">time_to_jump_type</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.time_to_medium_jump_vertex" href="#game_qu.platformer.player.Player.time_to_medium_jump_vertex">time_to_medium_jump_vertex</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.time_to_small_jump_vertex" href="#game_qu.platformer.player.Player.time_to_small_jump_vertex">time_to_small_jump_vertex</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.total_hit_points" href="#game_qu.platformer.player.Player.total_hit_points">total_hit_points</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.update_falling_path" href="#game_qu.platformer.player.Player.update_falling_path">update_falling_path</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.update_jump_types" href="#game_qu.platformer.player.Player.update_jump_types">update_jump_types</a></code></li>
<li><code><a title="game_qu.platformer.player.Player.update_jumping_path" href="#game_qu.platformer.player.Player.update_jumping_path">update_jumping_path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>