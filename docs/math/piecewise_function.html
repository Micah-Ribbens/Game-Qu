<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>game_qu.math.piecewise_function API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>game_qu.math.piecewise_function</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from copy import deepcopy

from game_qu.math.bounded_function import BoundedFunction
from game_qu.math.function import Function
from game_qu.base.utility_functions import modified_mod, is_within_bounds, min_value


class PiecewiseFunction(Function):
    &#34;&#34;&#34; A function that is made up of multiple functions. The function uses different functions depending on what the x
        coordinate is and if it falls within the other function&#34;&#34;&#34;

    functions = []
    is_repeating = False
    x_coordinates_can_be_less_than_min = True
    min_x_coordinate = 0
    max_x_coordinate = 0

    def __init__(self, functions):
        &#34;&#34;&#34;Initializes the object with the functions&#34;&#34;&#34;

        self.set_functions(functions)

    def get_functions(self):
        &#34;&#34;&#34;
             Returns:
                list[BoundedFunction]: all the functions of the piecewise function&#34;&#34;&#34;

        return self.functions

    def set_functions(self, functions):
        &#34;&#34;&#34;Sets the functions of the piecewise function

             Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions = functions
        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_functions(self, functions):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function with functions attribute being set to &#39;functions&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

        return self.get_copy().set_functions(functions)

    def get_copy(self):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a copy of the current piecewise_function&#34;&#34;&#34;

        # return deepcopy(self)
        new_functions = []
        copy = PiecewiseFunction(new_functions)
        for val in self.get_functions():
            new_functions.append(val)

        copy.set_is_repeating(self.is_repeating)
        copy.set_x_coordinates_can_be_less_than_min(self.x_coordinates_can_be_less_than_min)
        return copy


    def get_x_coordinates_can_be_less_than_min(self):
        &#34;&#34;&#34;
             Returns:
                bool: whether the x coordinates this function accepts can be less than the min x coordinate&#34;&#34;&#34;

        return self.x_coordinates_can_be_less_than_min

    def set_x_coordinates_can_be_less_than_min(self, x_coordinates_can_be_less_than_min):
        &#34;&#34;&#34; Sets whether the x coordinates this function accepts can be less than the min x coordinate

             Returns:
                BoundedFunction: &#39;self&#39;&#34;&#34;&#34;

        self.x_coordinates_can_be_less_than_min = x_coordinates_can_be_less_than_min
        return self

    def get_bounded_function_with_x_coordinates_less_than_min(self, x_coordinates_can_be_less_than_min):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function with the is repeating attribute set to &#39;x_coordinates_can_be_less_than_min&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

        return self.get_copy().set_x_coordinates_can_be_less_than_min(x_coordinates_can_be_less_than_min)

    def get_is_repeating(self):
        &#34;&#34;&#34;
             Returns:
                boolean: whether the piecewise function repeats&#34;&#34;&#34;

        return self.is_repeating

    def set_is_repeating(self, is_repeating):
        &#34;&#34;&#34;Sets the is_repeating attribute to &#39;is_repeating&#39;

             Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.is_repeating = is_repeating
        return self

    def get_piecewise_function_with_is_repeating(self, is_repeating):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function with the is repeating attribute set to &#39;is_repeating&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

        return self.get_copy().set_is_repeating(is_repeating)

    def update_function_bounds_fully(self):
        &#34;&#34;&#34;Updates the function bounds for operations like remove (has to check every function in the list)&#34;&#34;&#34;

        if len(self.functions) == 0:
            return

        self.functions = sorted(self.functions, key=lambda x: x.get_min_x_coordinate())
        self.min_x_coordinate = self.functions[0].get_min_x_coordinate()

        max_index = len(self.functions) - 1
        self.max_x_coordinate = self.functions[max_index].get_max_x_coordinate()

    def update_function_bounds_for_added_function(self, function):
        &#34;&#34;&#34;Updates the function bounds when a function is added (do not have to check every function in list)&#34;&#34;&#34;

        self.min_x_coordinate = min(self.min_x_coordinate, function.get_min_x_coordinate())
        self.max_x_coordinate = max(self.max_x_coordinate, function.get_max_x_coordinate())

    def validate_function_bounds_do_not_overlap(self):
        &#34;&#34;&#34;Raises a ValueError if the function bounds overlap (if there are overlapping bounds the piecewise function is invalidated)&#34;&#34;&#34;

        for i in range(len(self.functions)):
            for j in range(len(self.functions)):
                function1 = self.functions[i]
                function2 = self.functions[j]

                a, b = function1.get_bounds()
                c, d = function2.get_bounds()

                # If the function1&#39;s bounds fall within function2&#39;s bounds (case 1) or it crosses the bounds of
                # function2 (case 2) then this is no longer a valid piecewise function.
                is_invalid = a &lt;= c &lt;= b
                distance_between_c_and_a = a - c
                function1_bound_size = b - a
                is_invalid |= distance_between_c_and_a &gt;= function1_bound_size

                if is_invalid:
                        raise ValueError(&#34;The bounds of each function within the piecewise function must not overlap&#34;)

    def clear_functions(self):
        &#34;&#34;&#34; Clears all functions from the piecewise function

            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions.clear()
        self.min_x_coordinate = 0
        self.max_x_coordinate = 0
        return self

    def get_piecewise_function_with_cleared_functions(self):
        &#34;&#34;&#34;
             Returns a new PiecewiseFunction with cleared functions (does not modify the current piecewise function)

             Returns:
                PiecewiseFunction: new piecewise function with cleared functions&#34;&#34;&#34;

        return self.get_copy().clear_functions()

    def add_function(self, new_function):
        &#34;&#34;&#34; Adds a new function to the piecewise function

            Args:
                new_function (Function): function to be added

            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions.append(new_function)
        self.validate_function_bounds_do_not_overlap()
        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_added_function(self, new_function):
        &#34;&#34;&#34;
             Returns: a new PiecewiseFunction with the added function (does not modify the current piecewise function)
            
            Args:
                new_function (Function): function to be added
            
             Returns:
                PiecewiseFunction: new piecewise function with the added function&#34;&#34;&#34;

        return self.get_copy().add_function(new_function)

    def remove_function_at_index(self, index):
        &#34;&#34;&#34; Removes a function at the specified index from the piecewise function
            
            Args:
                index (int): index of the function to be removed
            
            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        if 0 &lt;= index &lt; len(self.functions):
            del self.functions[index]

        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_function_removed_at_index(self, index):
        &#34;&#34;&#34;
             Returns: a new PiecewiseFunction with a function removed at the specified index (does not modify the current piecewise function)
            Args:
                index (int): index of the function to be removed

             Returns:
               PiecewiseFunction: new piecewise function with the function removed at the specified index&#34;&#34;&#34;

        return self.get_copy().remove_function_at_index(index)

    def remove_function(self, function):
        &#34;&#34;&#34; Removes the specified function from the piecewise function

            Args:
                function (Function): function to be removed

            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions.remove(function)
        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_function_removed(self, function):
        &#34;&#34;&#34;
             Returns: a new PiecewiseFunction with the specified function removed (does not modify the current piecewise function)
            Args:
                function (Function): function to be removed

             Returns:
                PiecewiseFunction: new piecewise function with the specified function removed&#34;&#34;&#34;

        return self.get_copy().remove_function(function)

    def get_y_coordinate(self, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                float: the y coordinate associated with that x coordinate&#34;&#34;&#34;

        return self.get_function(x_coordinate).get_y_coordinate(x_coordinate)

    def get_function(self, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                BoundedFunction: the function that controls the piecewise function at the x coordinate&#34;&#34;&#34;

        if len(self.functions) == 0:
            raise ValueError(&#34;There must be a function in functions in order for the piecewise function to operate&#34;)

        if self.is_repeating:
            x_coordinate = modified_mod(x_coordinate, self.bounds_size())

        if not is_within_bounds(x_coordinate, self.min_x_coordinate, self.max_x_coordinate):
            if not self.x_coordinates_can_be_less_than_min:
                raise ValueError(&#34;The x coordinate must be greater&#34;)

            else:
                return self.get_before_piecewise_function().get_function(x_coordinate)

        for function in self.functions:
            if is_within_bounds(x_coordinate, *function.get_bounds()):
                return function

        raise ValueError(&#34;You should not get this value error! This is an implementation error in the code&#34;)



    def get_before_piecewise_function(self):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function that &#39;comes before&#39; the original&#34;&#34;&#34;

        before_piecewise_function = self.get_copy()
        new_x_start = self.min_x_coordinate - self.bounds_size()
        # The relative positions of functions stay the same, so I am just performing a &#39;domain shift&#39;
        x_position_in_original_function = lambda x: self.get_x_relative_position(new_x_start, x) + self.min_x_coordinate
        before_piecewise_function.get_y_coordinate = lambda x: self.get_y_coordinate(x_position_in_original_function(x))

        return before_piecewise_function

    def get_x_relative_position(self, start, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                float: the distance x is from start (the relative position within the interval [start, end])&#34;&#34;&#34;

        return start - x_coordinate


    def get_min_x_coordinate(self):
        &#34;&#34;&#34;
             Returns:
                float: the min x coordinate of the piecewise function (min x coordinate of min bounded function)&#34;&#34;&#34;

        return self.min_x_coordinate

    def get_max_x_coordinate(self):
        &#34;&#34;&#34;
             Returns:
                float: the max x coordinate of the piecewise function (max x coordinate of max bounded function)&#34;&#34;&#34;

        return self.max_x_coordinate

    def get_bounds(self):
        &#34;&#34;&#34;
             Returns:
                list[float]: {min_x_coordinate, max_x_coordinate}; the bounds of the peicewise function&#34;&#34;&#34;

        return [self.min_x_coordinate, self.max_x_coordinate]

    def bounds_size(self):
        &#34;&#34;&#34;
             Returns:
                float: the size of the bounds (max - min)&#34;&#34;&#34;

        return self.max_x_coordinate - self.min_x_coordinate

    def get_indefinite_integral(self):
        &#34;&#34;&#34; Finds and returns the indefinite integral. Raises an AttributeError if any of the functions do not have the
            method: &#39;get_indefinite_integral&#39;
     
            Returns:
                PiecewiseFunction: the indefinite integral of the polynomial&#34;&#34;&#34;

        new_functions = []
        for function in self.functions:
            new_functions.append(function.get_indefinite_integral())

        indefinite_integral = self.get_copy().get_piecewise_function_with_functions(new_functions)
        return indefinite_integral

    def evaluate_area(self, start, end):
        &#34;&#34;&#34;
             Returns:
                float: the value gotten from using the bounds for the indefinite integral&#34;&#34;&#34;

        indefinite_integral = self.get_indefinite_integral()
        area = 0
        current_start = start

        for x in range(len(indefinite_integral.get_functions())):
            bounded_function = indefinite_integral.get_functions()[x]
            min_x, max_x = bounded_function.get_bounds()

            if is_within_bounds(current_start, min_x, max_x):
                end_x = min_value(max_x, end)
                new_area = bounded_function.get_y_coordinate(end_x) - bounded_function.get_y_coordinate(current_start)
                area += new_area
                current_start = end_x

            if current_start == end:
                break

        return area

    def get_derivative(self):
        &#34;&#34;&#34; Finds and returns the derivative. Raises an AttributeError if any of the functions do not have the
            method: &#39;get_derivative&#39;
     
            Returns:
                PiecewiseFunction: the derivative of the polynomial&#34;&#34;&#34;

        new_functions = []
        for function in self.functions:
            new_functions.append(function.get_derivative())

        return self.get_piecewise_function_with_functions(new_functions)

    def evaluate_derivative_at_point(self, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                float: the value of the derivative evaluated at the &#39;x_coordinate&#39;&#34;&#34;&#34;

        return self.get_derivative().get_y_coordinate(x_coordinate)

    @staticmethod
    def get_bounded_functions_with_delta_times(functions, delta_times, start_time):
        &#34;&#34;&#34;
            Returns:
                list[BoundedFunction]: a list of the bounded functions the first one started at &#39;start_time&#39; and the
                rest are shifted by the delta times
        &#34;&#34;&#34;

        if len(functions) != len(delta_times):
            raise ValueError(&#34;The length of &#39;functions&#39; must be equal to the length of &#39;delta_times&#39;&#34;)

        bounded_functions = []
        current_start_time = start_time
        for x in range(len(delta_times)):
            end_time = current_start_time + delta_times[x]
            bounded_function = BoundedFunction(functions[x], current_start_time, end_time)
            bounded_functions.append(bounded_function)
            current_start_time = end_time

        return bounded_functions</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction"><code class="flex name class">
<span>class <span class="ident">PiecewiseFunction</span></span>
<span>(</span><span>functions)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that is made up of multiple functions. The function uses different functions depending on what the x
coordinate is and if it falls within the other function</p>
<p>Initializes the object with the functions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PiecewiseFunction(Function):
    &#34;&#34;&#34; A function that is made up of multiple functions. The function uses different functions depending on what the x
        coordinate is and if it falls within the other function&#34;&#34;&#34;

    functions = []
    is_repeating = False
    x_coordinates_can_be_less_than_min = True
    min_x_coordinate = 0
    max_x_coordinate = 0

    def __init__(self, functions):
        &#34;&#34;&#34;Initializes the object with the functions&#34;&#34;&#34;

        self.set_functions(functions)

    def get_functions(self):
        &#34;&#34;&#34;
             Returns:
                list[BoundedFunction]: all the functions of the piecewise function&#34;&#34;&#34;

        return self.functions

    def set_functions(self, functions):
        &#34;&#34;&#34;Sets the functions of the piecewise function

             Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions = functions
        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_functions(self, functions):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function with functions attribute being set to &#39;functions&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

        return self.get_copy().set_functions(functions)

    def get_copy(self):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a copy of the current piecewise_function&#34;&#34;&#34;

        # return deepcopy(self)
        new_functions = []
        copy = PiecewiseFunction(new_functions)
        for val in self.get_functions():
            new_functions.append(val)

        copy.set_is_repeating(self.is_repeating)
        copy.set_x_coordinates_can_be_less_than_min(self.x_coordinates_can_be_less_than_min)
        return copy


    def get_x_coordinates_can_be_less_than_min(self):
        &#34;&#34;&#34;
             Returns:
                bool: whether the x coordinates this function accepts can be less than the min x coordinate&#34;&#34;&#34;

        return self.x_coordinates_can_be_less_than_min

    def set_x_coordinates_can_be_less_than_min(self, x_coordinates_can_be_less_than_min):
        &#34;&#34;&#34; Sets whether the x coordinates this function accepts can be less than the min x coordinate

             Returns:
                BoundedFunction: &#39;self&#39;&#34;&#34;&#34;

        self.x_coordinates_can_be_less_than_min = x_coordinates_can_be_less_than_min
        return self

    def get_bounded_function_with_x_coordinates_less_than_min(self, x_coordinates_can_be_less_than_min):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function with the is repeating attribute set to &#39;x_coordinates_can_be_less_than_min&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

        return self.get_copy().set_x_coordinates_can_be_less_than_min(x_coordinates_can_be_less_than_min)

    def get_is_repeating(self):
        &#34;&#34;&#34;
             Returns:
                boolean: whether the piecewise function repeats&#34;&#34;&#34;

        return self.is_repeating

    def set_is_repeating(self, is_repeating):
        &#34;&#34;&#34;Sets the is_repeating attribute to &#39;is_repeating&#39;

             Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.is_repeating = is_repeating
        return self

    def get_piecewise_function_with_is_repeating(self, is_repeating):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function with the is repeating attribute set to &#39;is_repeating&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

        return self.get_copy().set_is_repeating(is_repeating)

    def update_function_bounds_fully(self):
        &#34;&#34;&#34;Updates the function bounds for operations like remove (has to check every function in the list)&#34;&#34;&#34;

        if len(self.functions) == 0:
            return

        self.functions = sorted(self.functions, key=lambda x: x.get_min_x_coordinate())
        self.min_x_coordinate = self.functions[0].get_min_x_coordinate()

        max_index = len(self.functions) - 1
        self.max_x_coordinate = self.functions[max_index].get_max_x_coordinate()

    def update_function_bounds_for_added_function(self, function):
        &#34;&#34;&#34;Updates the function bounds when a function is added (do not have to check every function in list)&#34;&#34;&#34;

        self.min_x_coordinate = min(self.min_x_coordinate, function.get_min_x_coordinate())
        self.max_x_coordinate = max(self.max_x_coordinate, function.get_max_x_coordinate())

    def validate_function_bounds_do_not_overlap(self):
        &#34;&#34;&#34;Raises a ValueError if the function bounds overlap (if there are overlapping bounds the piecewise function is invalidated)&#34;&#34;&#34;

        for i in range(len(self.functions)):
            for j in range(len(self.functions)):
                function1 = self.functions[i]
                function2 = self.functions[j]

                a, b = function1.get_bounds()
                c, d = function2.get_bounds()

                # If the function1&#39;s bounds fall within function2&#39;s bounds (case 1) or it crosses the bounds of
                # function2 (case 2) then this is no longer a valid piecewise function.
                is_invalid = a &lt;= c &lt;= b
                distance_between_c_and_a = a - c
                function1_bound_size = b - a
                is_invalid |= distance_between_c_and_a &gt;= function1_bound_size

                if is_invalid:
                        raise ValueError(&#34;The bounds of each function within the piecewise function must not overlap&#34;)

    def clear_functions(self):
        &#34;&#34;&#34; Clears all functions from the piecewise function

            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions.clear()
        self.min_x_coordinate = 0
        self.max_x_coordinate = 0
        return self

    def get_piecewise_function_with_cleared_functions(self):
        &#34;&#34;&#34;
             Returns a new PiecewiseFunction with cleared functions (does not modify the current piecewise function)

             Returns:
                PiecewiseFunction: new piecewise function with cleared functions&#34;&#34;&#34;

        return self.get_copy().clear_functions()

    def add_function(self, new_function):
        &#34;&#34;&#34; Adds a new function to the piecewise function

            Args:
                new_function (Function): function to be added

            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions.append(new_function)
        self.validate_function_bounds_do_not_overlap()
        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_added_function(self, new_function):
        &#34;&#34;&#34;
             Returns: a new PiecewiseFunction with the added function (does not modify the current piecewise function)
            
            Args:
                new_function (Function): function to be added
            
             Returns:
                PiecewiseFunction: new piecewise function with the added function&#34;&#34;&#34;

        return self.get_copy().add_function(new_function)

    def remove_function_at_index(self, index):
        &#34;&#34;&#34; Removes a function at the specified index from the piecewise function
            
            Args:
                index (int): index of the function to be removed
            
            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        if 0 &lt;= index &lt; len(self.functions):
            del self.functions[index]

        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_function_removed_at_index(self, index):
        &#34;&#34;&#34;
             Returns: a new PiecewiseFunction with a function removed at the specified index (does not modify the current piecewise function)
            Args:
                index (int): index of the function to be removed

             Returns:
               PiecewiseFunction: new piecewise function with the function removed at the specified index&#34;&#34;&#34;

        return self.get_copy().remove_function_at_index(index)

    def remove_function(self, function):
        &#34;&#34;&#34; Removes the specified function from the piecewise function

            Args:
                function (Function): function to be removed

            Returns:
                PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

        self.functions.remove(function)
        self.update_function_bounds_fully()
        return self

    def get_piecewise_function_with_function_removed(self, function):
        &#34;&#34;&#34;
             Returns: a new PiecewiseFunction with the specified function removed (does not modify the current piecewise function)
            Args:
                function (Function): function to be removed

             Returns:
                PiecewiseFunction: new piecewise function with the specified function removed&#34;&#34;&#34;

        return self.get_copy().remove_function(function)

    def get_y_coordinate(self, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                float: the y coordinate associated with that x coordinate&#34;&#34;&#34;

        return self.get_function(x_coordinate).get_y_coordinate(x_coordinate)

    def get_function(self, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                BoundedFunction: the function that controls the piecewise function at the x coordinate&#34;&#34;&#34;

        if len(self.functions) == 0:
            raise ValueError(&#34;There must be a function in functions in order for the piecewise function to operate&#34;)

        if self.is_repeating:
            x_coordinate = modified_mod(x_coordinate, self.bounds_size())

        if not is_within_bounds(x_coordinate, self.min_x_coordinate, self.max_x_coordinate):
            if not self.x_coordinates_can_be_less_than_min:
                raise ValueError(&#34;The x coordinate must be greater&#34;)

            else:
                return self.get_before_piecewise_function().get_function(x_coordinate)

        for function in self.functions:
            if is_within_bounds(x_coordinate, *function.get_bounds()):
                return function

        raise ValueError(&#34;You should not get this value error! This is an implementation error in the code&#34;)



    def get_before_piecewise_function(self):
        &#34;&#34;&#34;
             Returns:
                PiecewiseFunction: a piecewise function that &#39;comes before&#39; the original&#34;&#34;&#34;

        before_piecewise_function = self.get_copy()
        new_x_start = self.min_x_coordinate - self.bounds_size()
        # The relative positions of functions stay the same, so I am just performing a &#39;domain shift&#39;
        x_position_in_original_function = lambda x: self.get_x_relative_position(new_x_start, x) + self.min_x_coordinate
        before_piecewise_function.get_y_coordinate = lambda x: self.get_y_coordinate(x_position_in_original_function(x))

        return before_piecewise_function

    def get_x_relative_position(self, start, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                float: the distance x is from start (the relative position within the interval [start, end])&#34;&#34;&#34;

        return start - x_coordinate


    def get_min_x_coordinate(self):
        &#34;&#34;&#34;
             Returns:
                float: the min x coordinate of the piecewise function (min x coordinate of min bounded function)&#34;&#34;&#34;

        return self.min_x_coordinate

    def get_max_x_coordinate(self):
        &#34;&#34;&#34;
             Returns:
                float: the max x coordinate of the piecewise function (max x coordinate of max bounded function)&#34;&#34;&#34;

        return self.max_x_coordinate

    def get_bounds(self):
        &#34;&#34;&#34;
             Returns:
                list[float]: {min_x_coordinate, max_x_coordinate}; the bounds of the peicewise function&#34;&#34;&#34;

        return [self.min_x_coordinate, self.max_x_coordinate]

    def bounds_size(self):
        &#34;&#34;&#34;
             Returns:
                float: the size of the bounds (max - min)&#34;&#34;&#34;

        return self.max_x_coordinate - self.min_x_coordinate

    def get_indefinite_integral(self):
        &#34;&#34;&#34; Finds and returns the indefinite integral. Raises an AttributeError if any of the functions do not have the
            method: &#39;get_indefinite_integral&#39;
     
            Returns:
                PiecewiseFunction: the indefinite integral of the polynomial&#34;&#34;&#34;

        new_functions = []
        for function in self.functions:
            new_functions.append(function.get_indefinite_integral())

        indefinite_integral = self.get_copy().get_piecewise_function_with_functions(new_functions)
        return indefinite_integral

    def evaluate_area(self, start, end):
        &#34;&#34;&#34;
             Returns:
                float: the value gotten from using the bounds for the indefinite integral&#34;&#34;&#34;

        indefinite_integral = self.get_indefinite_integral()
        area = 0
        current_start = start

        for x in range(len(indefinite_integral.get_functions())):
            bounded_function = indefinite_integral.get_functions()[x]
            min_x, max_x = bounded_function.get_bounds()

            if is_within_bounds(current_start, min_x, max_x):
                end_x = min_value(max_x, end)
                new_area = bounded_function.get_y_coordinate(end_x) - bounded_function.get_y_coordinate(current_start)
                area += new_area
                current_start = end_x

            if current_start == end:
                break

        return area

    def get_derivative(self):
        &#34;&#34;&#34; Finds and returns the derivative. Raises an AttributeError if any of the functions do not have the
            method: &#39;get_derivative&#39;
     
            Returns:
                PiecewiseFunction: the derivative of the polynomial&#34;&#34;&#34;

        new_functions = []
        for function in self.functions:
            new_functions.append(function.get_derivative())

        return self.get_piecewise_function_with_functions(new_functions)

    def evaluate_derivative_at_point(self, x_coordinate):
        &#34;&#34;&#34;
             Returns:
                float: the value of the derivative evaluated at the &#39;x_coordinate&#39;&#34;&#34;&#34;

        return self.get_derivative().get_y_coordinate(x_coordinate)

    @staticmethod
    def get_bounded_functions_with_delta_times(functions, delta_times, start_time):
        &#34;&#34;&#34;
            Returns:
                list[BoundedFunction]: a list of the bounded functions the first one started at &#39;start_time&#39; and the
                rest are shifted by the delta times
        &#34;&#34;&#34;

        if len(functions) != len(delta_times):
            raise ValueError(&#34;The length of &#39;functions&#39; must be equal to the length of &#39;delta_times&#39;&#34;)

        bounded_functions = []
        current_start_time = start_time
        for x in range(len(delta_times)):
            end_time = current_start_time + delta_times[x]
            bounded_function = BoundedFunction(functions[x], current_start_time, end_time)
            bounded_functions.append(bounded_function)
            current_start_time = end_time

        return bounded_functions</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="game_qu.math.function.Function" href="function.html#game_qu.math.function.Function">Function</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.functions"><code class="name">var <span class="ident">functions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.is_repeating"><code class="name">var <span class="ident">is_repeating</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.max_x_coordinate"><code class="name">var <span class="ident">max_x_coordinate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.min_x_coordinate"><code class="name">var <span class="ident">min_x_coordinate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.x_coordinates_can_be_less_than_min"><code class="name">var <span class="ident">x_coordinates_can_be_less_than_min</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_bounded_functions_with_delta_times"><code class="name flex">
<span>def <span class="ident">get_bounded_functions_with_delta_times</span></span>(<span>functions, delta_times, start_time)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list[BoundedFunction]</code></dt>
<dd>a list of the bounded functions the first one started at 'start_time' and the</dd>
</dl>
<p>rest are shifted by the delta times</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_bounded_functions_with_delta_times(functions, delta_times, start_time):
    &#34;&#34;&#34;
        Returns:
            list[BoundedFunction]: a list of the bounded functions the first one started at &#39;start_time&#39; and the
            rest are shifted by the delta times
    &#34;&#34;&#34;

    if len(functions) != len(delta_times):
        raise ValueError(&#34;The length of &#39;functions&#39; must be equal to the length of &#39;delta_times&#39;&#34;)

    bounded_functions = []
    current_start_time = start_time
    for x in range(len(delta_times)):
        end_time = current_start_time + delta_times[x]
        bounded_function = BoundedFunction(functions[x], current_start_time, end_time)
        bounded_functions.append(bounded_function)
        current_start_time = end_time

    return bounded_functions</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.add_function"><code class="name flex">
<span>def <span class="ident">add_function</span></span>(<span>self, new_function)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new function to the piecewise function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_function</code></strong> :&ensp;<code>Function</code></dt>
<dd>function to be added</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>'self'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_function(self, new_function):
    &#34;&#34;&#34; Adds a new function to the piecewise function

        Args:
            new_function (Function): function to be added

        Returns:
            PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

    self.functions.append(new_function)
    self.validate_function_bounds_do_not_overlap()
    self.update_function_bounds_fully()
    return self</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.bounds_size"><code class="name flex">
<span>def <span class="ident">bounds_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the size of the bounds (max - min)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounds_size(self):
    &#34;&#34;&#34;
         Returns:
            float: the size of the bounds (max - min)&#34;&#34;&#34;

    return self.max_x_coordinate - self.min_x_coordinate</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.clear_functions"><code class="name flex">
<span>def <span class="ident">clear_functions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears all functions from the piecewise function</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>'self'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_functions(self):
    &#34;&#34;&#34; Clears all functions from the piecewise function

        Returns:
            PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

    self.functions.clear()
    self.min_x_coordinate = 0
    self.max_x_coordinate = 0
    return self</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.evaluate_area"><code class="name flex">
<span>def <span class="ident">evaluate_area</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the value gotten from using the bounds for the indefinite integral</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_area(self, start, end):
    &#34;&#34;&#34;
         Returns:
            float: the value gotten from using the bounds for the indefinite integral&#34;&#34;&#34;

    indefinite_integral = self.get_indefinite_integral()
    area = 0
    current_start = start

    for x in range(len(indefinite_integral.get_functions())):
        bounded_function = indefinite_integral.get_functions()[x]
        min_x, max_x = bounded_function.get_bounds()

        if is_within_bounds(current_start, min_x, max_x):
            end_x = min_value(max_x, end)
            new_area = bounded_function.get_y_coordinate(end_x) - bounded_function.get_y_coordinate(current_start)
            area += new_area
            current_start = end_x

        if current_start == end:
            break

    return area</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.evaluate_derivative_at_point"><code class="name flex">
<span>def <span class="ident">evaluate_derivative_at_point</span></span>(<span>self, x_coordinate)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the value of the derivative evaluated at the 'x_coordinate'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_derivative_at_point(self, x_coordinate):
    &#34;&#34;&#34;
         Returns:
            float: the value of the derivative evaluated at the &#39;x_coordinate&#39;&#34;&#34;&#34;

    return self.get_derivative().get_y_coordinate(x_coordinate)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_before_piecewise_function"><code class="name flex">
<span>def <span class="ident">get_before_piecewise_function</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>a piecewise function that 'comes before' the original</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_before_piecewise_function(self):
    &#34;&#34;&#34;
         Returns:
            PiecewiseFunction: a piecewise function that &#39;comes before&#39; the original&#34;&#34;&#34;

    before_piecewise_function = self.get_copy()
    new_x_start = self.min_x_coordinate - self.bounds_size()
    # The relative positions of functions stay the same, so I am just performing a &#39;domain shift&#39;
    x_position_in_original_function = lambda x: self.get_x_relative_position(new_x_start, x) + self.min_x_coordinate
    before_piecewise_function.get_y_coordinate = lambda x: self.get_y_coordinate(x_position_in_original_function(x))

    return before_piecewise_function</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_bounded_function_with_x_coordinates_less_than_min"><code class="name flex">
<span>def <span class="ident">get_bounded_function_with_x_coordinates_less_than_min</span></span>(<span>self, x_coordinates_can_be_less_than_min)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>a piecewise function with the is repeating attribute set to 'x_coordinates_can_be_less_than_min' (does not modify the current piecewise function)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounded_function_with_x_coordinates_less_than_min(self, x_coordinates_can_be_less_than_min):
    &#34;&#34;&#34;
         Returns:
            PiecewiseFunction: a piecewise function with the is repeating attribute set to &#39;x_coordinates_can_be_less_than_min&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

    return self.get_copy().set_x_coordinates_can_be_less_than_min(x_coordinates_can_be_less_than_min)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_bounds"><code class="name flex">
<span>def <span class="ident">get_bounds</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list[float]</code></dt>
<dd>{min_x_coordinate, max_x_coordinate}; the bounds of the peicewise function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bounds(self):
    &#34;&#34;&#34;
         Returns:
            list[float]: {min_x_coordinate, max_x_coordinate}; the bounds of the peicewise function&#34;&#34;&#34;

    return [self.min_x_coordinate, self.max_x_coordinate]</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_copy"><code class="name flex">
<span>def <span class="ident">get_copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>a copy of the current piecewise_function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_copy(self):
    &#34;&#34;&#34;
         Returns:
            PiecewiseFunction: a copy of the current piecewise_function&#34;&#34;&#34;

    # return deepcopy(self)
    new_functions = []
    copy = PiecewiseFunction(new_functions)
    for val in self.get_functions():
        new_functions.append(val)

    copy.set_is_repeating(self.is_repeating)
    copy.set_x_coordinates_can_be_less_than_min(self.x_coordinates_can_be_less_than_min)
    return copy</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_derivative"><code class="name flex">
<span>def <span class="ident">get_derivative</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds and returns the derivative. Raises an AttributeError if any of the functions do not have the
method: 'get_derivative'</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>the derivative of the polynomial</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_derivative(self):
    &#34;&#34;&#34; Finds and returns the derivative. Raises an AttributeError if any of the functions do not have the
        method: &#39;get_derivative&#39;
 
        Returns:
            PiecewiseFunction: the derivative of the polynomial&#34;&#34;&#34;

    new_functions = []
    for function in self.functions:
        new_functions.append(function.get_derivative())

    return self.get_piecewise_function_with_functions(new_functions)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_function"><code class="name flex">
<span>def <span class="ident">get_function</span></span>(<span>self, x_coordinate)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>BoundedFunction</code></dt>
<dd>the function that controls the piecewise function at the x coordinate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function(self, x_coordinate):
    &#34;&#34;&#34;
         Returns:
            BoundedFunction: the function that controls the piecewise function at the x coordinate&#34;&#34;&#34;

    if len(self.functions) == 0:
        raise ValueError(&#34;There must be a function in functions in order for the piecewise function to operate&#34;)

    if self.is_repeating:
        x_coordinate = modified_mod(x_coordinate, self.bounds_size())

    if not is_within_bounds(x_coordinate, self.min_x_coordinate, self.max_x_coordinate):
        if not self.x_coordinates_can_be_less_than_min:
            raise ValueError(&#34;The x coordinate must be greater&#34;)

        else:
            return self.get_before_piecewise_function().get_function(x_coordinate)

    for function in self.functions:
        if is_within_bounds(x_coordinate, *function.get_bounds()):
            return function

    raise ValueError(&#34;You should not get this value error! This is an implementation error in the code&#34;)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_functions"><code class="name flex">
<span>def <span class="ident">get_functions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list[BoundedFunction]</code></dt>
<dd>all the functions of the piecewise function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_functions(self):
    &#34;&#34;&#34;
         Returns:
            list[BoundedFunction]: all the functions of the piecewise function&#34;&#34;&#34;

    return self.functions</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_indefinite_integral"><code class="name flex">
<span>def <span class="ident">get_indefinite_integral</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds and returns the indefinite integral. Raises an AttributeError if any of the functions do not have the
method: 'get_indefinite_integral'</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>the indefinite integral of the polynomial</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_indefinite_integral(self):
    &#34;&#34;&#34; Finds and returns the indefinite integral. Raises an AttributeError if any of the functions do not have the
        method: &#39;get_indefinite_integral&#39;
 
        Returns:
            PiecewiseFunction: the indefinite integral of the polynomial&#34;&#34;&#34;

    new_functions = []
    for function in self.functions:
        new_functions.append(function.get_indefinite_integral())

    indefinite_integral = self.get_copy().get_piecewise_function_with_functions(new_functions)
    return indefinite_integral</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_is_repeating"><code class="name flex">
<span>def <span class="ident">get_is_repeating</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>whether the piecewise function repeats</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_is_repeating(self):
    &#34;&#34;&#34;
         Returns:
            boolean: whether the piecewise function repeats&#34;&#34;&#34;

    return self.is_repeating</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_max_x_coordinate"><code class="name flex">
<span>def <span class="ident">get_max_x_coordinate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the max x coordinate of the piecewise function (max x coordinate of max bounded function)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_x_coordinate(self):
    &#34;&#34;&#34;
         Returns:
            float: the max x coordinate of the piecewise function (max x coordinate of max bounded function)&#34;&#34;&#34;

    return self.max_x_coordinate</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_min_x_coordinate"><code class="name flex">
<span>def <span class="ident">get_min_x_coordinate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the min x coordinate of the piecewise function (min x coordinate of min bounded function)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_x_coordinate(self):
    &#34;&#34;&#34;
         Returns:
            float: the min x coordinate of the piecewise function (min x coordinate of min bounded function)&#34;&#34;&#34;

    return self.min_x_coordinate</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_added_function"><code class="name flex">
<span>def <span class="ident">get_piecewise_function_with_added_function</span></span>(<span>self, new_function)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: a new PiecewiseFunction with the added function (does not modify the current piecewise function)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_function</code></strong> :&ensp;<code>Function</code></dt>
<dd>function to be added</dd>
</dl>
<p>Returns:
PiecewiseFunction: new piecewise function with the added function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_piecewise_function_with_added_function(self, new_function):
    &#34;&#34;&#34;
         Returns: a new PiecewiseFunction with the added function (does not modify the current piecewise function)
        
        Args:
            new_function (Function): function to be added
        
         Returns:
            PiecewiseFunction: new piecewise function with the added function&#34;&#34;&#34;

    return self.get_copy().add_function(new_function)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_cleared_functions"><code class="name flex">
<span>def <span class="ident">get_piecewise_function_with_cleared_functions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new PiecewiseFunction with cleared functions (does not modify the current piecewise function)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>new piecewise function with cleared functions</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_piecewise_function_with_cleared_functions(self):
    &#34;&#34;&#34;
         Returns a new PiecewiseFunction with cleared functions (does not modify the current piecewise function)

         Returns:
            PiecewiseFunction: new piecewise function with cleared functions&#34;&#34;&#34;

    return self.get_copy().clear_functions()</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_function_removed"><code class="name flex">
<span>def <span class="ident">get_piecewise_function_with_function_removed</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: a new PiecewiseFunction with the specified function removed (does not modify the current piecewise function)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Function</code></dt>
<dd>function to be removed</dd>
</dl>
<p>Returns:
PiecewiseFunction: new piecewise function with the specified function removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_piecewise_function_with_function_removed(self, function):
    &#34;&#34;&#34;
         Returns: a new PiecewiseFunction with the specified function removed (does not modify the current piecewise function)
        Args:
            function (Function): function to be removed

         Returns:
            PiecewiseFunction: new piecewise function with the specified function removed&#34;&#34;&#34;

    return self.get_copy().remove_function(function)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_function_removed_at_index"><code class="name flex">
<span>def <span class="ident">get_piecewise_function_with_function_removed_at_index</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns: a new PiecewiseFunction with a function removed at the specified index (does not modify the current piecewise function)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the function to be removed</dd>
</dl>
<p>Returns:
PiecewiseFunction: new piecewise function with the function removed at the specified index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_piecewise_function_with_function_removed_at_index(self, index):
    &#34;&#34;&#34;
         Returns: a new PiecewiseFunction with a function removed at the specified index (does not modify the current piecewise function)
        Args:
            index (int): index of the function to be removed

         Returns:
           PiecewiseFunction: new piecewise function with the function removed at the specified index&#34;&#34;&#34;

    return self.get_copy().remove_function_at_index(index)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_functions"><code class="name flex">
<span>def <span class="ident">get_piecewise_function_with_functions</span></span>(<span>self, functions)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>a piecewise function with functions attribute being set to 'functions' (does not modify the current piecewise function)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_piecewise_function_with_functions(self, functions):
    &#34;&#34;&#34;
         Returns:
            PiecewiseFunction: a piecewise function with functions attribute being set to &#39;functions&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

    return self.get_copy().set_functions(functions)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_is_repeating"><code class="name flex">
<span>def <span class="ident">get_piecewise_function_with_is_repeating</span></span>(<span>self, is_repeating)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>a piecewise function with the is repeating attribute set to 'is_repeating' (does not modify the current piecewise function)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_piecewise_function_with_is_repeating(self, is_repeating):
    &#34;&#34;&#34;
         Returns:
            PiecewiseFunction: a piecewise function with the is repeating attribute set to &#39;is_repeating&#39; (does not modify the current piecewise function)&#34;&#34;&#34;

    return self.get_copy().set_is_repeating(is_repeating)</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_x_coordinates_can_be_less_than_min"><code class="name flex">
<span>def <span class="ident">get_x_coordinates_can_be_less_than_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>whether the x coordinates this function accepts can be less than the min x coordinate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x_coordinates_can_be_less_than_min(self):
    &#34;&#34;&#34;
         Returns:
            bool: whether the x coordinates this function accepts can be less than the min x coordinate&#34;&#34;&#34;

    return self.x_coordinates_can_be_less_than_min</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.get_x_relative_position"><code class="name flex">
<span>def <span class="ident">get_x_relative_position</span></span>(<span>self, start, x_coordinate)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the distance x is from start (the relative position within the interval [start, end])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x_relative_position(self, start, x_coordinate):
    &#34;&#34;&#34;
         Returns:
            float: the distance x is from start (the relative position within the interval [start, end])&#34;&#34;&#34;

    return start - x_coordinate</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.remove_function"><code class="name flex">
<span>def <span class="ident">remove_function</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the specified function from the piecewise function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Function</code></dt>
<dd>function to be removed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>'self'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_function(self, function):
    &#34;&#34;&#34; Removes the specified function from the piecewise function

        Args:
            function (Function): function to be removed

        Returns:
            PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

    self.functions.remove(function)
    self.update_function_bounds_fully()
    return self</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.remove_function_at_index"><code class="name flex">
<span>def <span class="ident">remove_function_at_index</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a function at the specified index from the piecewise function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the function to be removed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>'self'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_function_at_index(self, index):
    &#34;&#34;&#34; Removes a function at the specified index from the piecewise function
        
        Args:
            index (int): index of the function to be removed
        
        Returns:
            PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

    if 0 &lt;= index &lt; len(self.functions):
        del self.functions[index]

    self.update_function_bounds_fully()
    return self</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.set_functions"><code class="name flex">
<span>def <span class="ident">set_functions</span></span>(<span>self, functions)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the functions of the piecewise function</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>'self'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_functions(self, functions):
    &#34;&#34;&#34;Sets the functions of the piecewise function

         Returns:
            PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

    self.functions = functions
    self.update_function_bounds_fully()
    return self</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.set_is_repeating"><code class="name flex">
<span>def <span class="ident">set_is_repeating</span></span>(<span>self, is_repeating)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the is_repeating attribute to 'is_repeating'</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></dt>
<dd>'self'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_repeating(self, is_repeating):
    &#34;&#34;&#34;Sets the is_repeating attribute to &#39;is_repeating&#39;

         Returns:
            PiecewiseFunction: &#39;self&#39;&#34;&#34;&#34;

    self.is_repeating = is_repeating
    return self</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.set_x_coordinates_can_be_less_than_min"><code class="name flex">
<span>def <span class="ident">set_x_coordinates_can_be_less_than_min</span></span>(<span>self, x_coordinates_can_be_less_than_min)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets whether the x coordinates this function accepts can be less than the min x coordinate</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BoundedFunction</code></dt>
<dd>'self'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x_coordinates_can_be_less_than_min(self, x_coordinates_can_be_less_than_min):
    &#34;&#34;&#34; Sets whether the x coordinates this function accepts can be less than the min x coordinate

         Returns:
            BoundedFunction: &#39;self&#39;&#34;&#34;&#34;

    self.x_coordinates_can_be_less_than_min = x_coordinates_can_be_less_than_min
    return self</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.update_function_bounds_for_added_function"><code class="name flex">
<span>def <span class="ident">update_function_bounds_for_added_function</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the function bounds when a function is added (do not have to check every function in list)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_function_bounds_for_added_function(self, function):
    &#34;&#34;&#34;Updates the function bounds when a function is added (do not have to check every function in list)&#34;&#34;&#34;

    self.min_x_coordinate = min(self.min_x_coordinate, function.get_min_x_coordinate())
    self.max_x_coordinate = max(self.max_x_coordinate, function.get_max_x_coordinate())</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.update_function_bounds_fully"><code class="name flex">
<span>def <span class="ident">update_function_bounds_fully</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the function bounds for operations like remove (has to check every function in the list)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_function_bounds_fully(self):
    &#34;&#34;&#34;Updates the function bounds for operations like remove (has to check every function in the list)&#34;&#34;&#34;

    if len(self.functions) == 0:
        return

    self.functions = sorted(self.functions, key=lambda x: x.get_min_x_coordinate())
    self.min_x_coordinate = self.functions[0].get_min_x_coordinate()

    max_index = len(self.functions) - 1
    self.max_x_coordinate = self.functions[max_index].get_max_x_coordinate()</code></pre>
</details>
</dd>
<dt id="game_qu.math.piecewise_function.PiecewiseFunction.validate_function_bounds_do_not_overlap"><code class="name flex">
<span>def <span class="ident">validate_function_bounds_do_not_overlap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises a ValueError if the function bounds overlap (if there are overlapping bounds the piecewise function is invalidated)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_function_bounds_do_not_overlap(self):
    &#34;&#34;&#34;Raises a ValueError if the function bounds overlap (if there are overlapping bounds the piecewise function is invalidated)&#34;&#34;&#34;

    for i in range(len(self.functions)):
        for j in range(len(self.functions)):
            function1 = self.functions[i]
            function2 = self.functions[j]

            a, b = function1.get_bounds()
            c, d = function2.get_bounds()

            # If the function1&#39;s bounds fall within function2&#39;s bounds (case 1) or it crosses the bounds of
            # function2 (case 2) then this is no longer a valid piecewise function.
            is_invalid = a &lt;= c &lt;= b
            distance_between_c_and_a = a - c
            function1_bound_size = b - a
            is_invalid |= distance_between_c_and_a &gt;= function1_bound_size

            if is_invalid:
                    raise ValueError(&#34;The bounds of each function within the piecewise function must not overlap&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="game_qu.math.function.Function" href="function.html#game_qu.math.function.Function">Function</a></b></code>:
<ul class="hlist">
<li><code><a title="game_qu.math.function.Function.get_inverted_function" href="function.html#game_qu.math.function.Function.get_inverted_function">get_inverted_function</a></code></li>
<li><code><a title="game_qu.math.function.Function.get_new_function" href="function.html#game_qu.math.function.Function.get_new_function">get_new_function</a></code></li>
<li><code><a title="game_qu.math.function.Function.get_x_coordinate" href="function.html#game_qu.math.function.Function.get_x_coordinate">get_x_coordinate</a></code></li>
<li><code><a title="game_qu.math.function.Function.get_y_coordinate" href="function.html#game_qu.math.function.Function.get_y_coordinate">get_y_coordinate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="game_qu.math" href="index.html">game_qu.math</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="game_qu.math.piecewise_function.PiecewiseFunction" href="#game_qu.math.piecewise_function.PiecewiseFunction">PiecewiseFunction</a></code></h4>
<ul class="">
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.add_function" href="#game_qu.math.piecewise_function.PiecewiseFunction.add_function">add_function</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.bounds_size" href="#game_qu.math.piecewise_function.PiecewiseFunction.bounds_size">bounds_size</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.clear_functions" href="#game_qu.math.piecewise_function.PiecewiseFunction.clear_functions">clear_functions</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.evaluate_area" href="#game_qu.math.piecewise_function.PiecewiseFunction.evaluate_area">evaluate_area</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.evaluate_derivative_at_point" href="#game_qu.math.piecewise_function.PiecewiseFunction.evaluate_derivative_at_point">evaluate_derivative_at_point</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.functions" href="#game_qu.math.piecewise_function.PiecewiseFunction.functions">functions</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_before_piecewise_function" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_before_piecewise_function">get_before_piecewise_function</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_bounded_function_with_x_coordinates_less_than_min" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_bounded_function_with_x_coordinates_less_than_min">get_bounded_function_with_x_coordinates_less_than_min</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_bounded_functions_with_delta_times" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_bounded_functions_with_delta_times">get_bounded_functions_with_delta_times</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_bounds" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_bounds">get_bounds</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_copy" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_copy">get_copy</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_derivative" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_derivative">get_derivative</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_function" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_function">get_function</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_functions" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_functions">get_functions</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_indefinite_integral" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_indefinite_integral">get_indefinite_integral</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_is_repeating" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_is_repeating">get_is_repeating</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_max_x_coordinate" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_max_x_coordinate">get_max_x_coordinate</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_min_x_coordinate" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_min_x_coordinate">get_min_x_coordinate</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_added_function" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_added_function">get_piecewise_function_with_added_function</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_cleared_functions" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_cleared_functions">get_piecewise_function_with_cleared_functions</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_function_removed" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_function_removed">get_piecewise_function_with_function_removed</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_function_removed_at_index" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_function_removed_at_index">get_piecewise_function_with_function_removed_at_index</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_functions" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_functions">get_piecewise_function_with_functions</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_is_repeating" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_piecewise_function_with_is_repeating">get_piecewise_function_with_is_repeating</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_x_coordinates_can_be_less_than_min" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_x_coordinates_can_be_less_than_min">get_x_coordinates_can_be_less_than_min</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.get_x_relative_position" href="#game_qu.math.piecewise_function.PiecewiseFunction.get_x_relative_position">get_x_relative_position</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.is_repeating" href="#game_qu.math.piecewise_function.PiecewiseFunction.is_repeating">is_repeating</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.max_x_coordinate" href="#game_qu.math.piecewise_function.PiecewiseFunction.max_x_coordinate">max_x_coordinate</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.min_x_coordinate" href="#game_qu.math.piecewise_function.PiecewiseFunction.min_x_coordinate">min_x_coordinate</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.remove_function" href="#game_qu.math.piecewise_function.PiecewiseFunction.remove_function">remove_function</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.remove_function_at_index" href="#game_qu.math.piecewise_function.PiecewiseFunction.remove_function_at_index">remove_function_at_index</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.set_functions" href="#game_qu.math.piecewise_function.PiecewiseFunction.set_functions">set_functions</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.set_is_repeating" href="#game_qu.math.piecewise_function.PiecewiseFunction.set_is_repeating">set_is_repeating</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.set_x_coordinates_can_be_less_than_min" href="#game_qu.math.piecewise_function.PiecewiseFunction.set_x_coordinates_can_be_less_than_min">set_x_coordinates_can_be_less_than_min</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.update_function_bounds_for_added_function" href="#game_qu.math.piecewise_function.PiecewiseFunction.update_function_bounds_for_added_function">update_function_bounds_for_added_function</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.update_function_bounds_fully" href="#game_qu.math.piecewise_function.PiecewiseFunction.update_function_bounds_fully">update_function_bounds_fully</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.validate_function_bounds_do_not_overlap" href="#game_qu.math.piecewise_function.PiecewiseFunction.validate_function_bounds_do_not_overlap">validate_function_bounds_do_not_overlap</a></code></li>
<li><code><a title="game_qu.math.piecewise_function.PiecewiseFunction.x_coordinates_can_be_less_than_min" href="#game_qu.math.piecewise_function.PiecewiseFunction.x_coordinates_can_be_less_than_min">x_coordinates_can_be_less_than_min</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>